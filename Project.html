<head>
    <script src="gl-matrix-min.js"></script>
    <script>
        function main() {
            canvas = document.querySelector("#glCanvas");
            canvas.addEventListener("mousedown", doMouseDown, false);
            // Initialize the GL context
            const gl = canvas.getContext("webgl");
        
            // Only continue if WebGL is available and working
            if (gl === null) {
                alert("Unable to initialize WebGL. Your browser or machine may not support it.");
                return;
            }
        
            // Vertex shader program
            const vsSource = `
                attribute vec4 aVertexPosition;
                attribute vec3 aVertexNormal; // ** LIGHTING **
                attribute vec4 aVertexColor;

                uniform mat4 uNormalMatrix; // ** LIGHTING **
                uniform mat4 uModelViewMatrix;
                uniform mat4 uProjectionMatrix;

                varying lowp vec4 vColor;
                varying highp vec3 vLighting; // ** LIGHTING **

                void main(void) {
                    gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
                    vColor = aVertexColor;

                    // Apply lighting effect // ** LIGHTING **

                    highp vec3 ambientLight = vec3(0.15, 0.15, 0.15); // ambient light
                    highp vec3 directionalLightColor = vec3(0.45, 0.45, 0.45); // light color // (1, 1, 1) is full white
                    highp vec3 directionalVector = normalize(vec3(0.85, 0.4, 0.75));

                    highp vec4 transformedNormal = uNormalMatrix * vec4(aVertexNormal, 1.0);

                    highp float directional = max(dot(transformedNormal.xyz, directionalVector), 0.0);
                    vLighting = ambientLight + (directionalLightColor * directional);
                    //vLighting = ambientLight;
                    //vLighting = directionalLightColor * directional;
                }
            `;

            // Fragment shader program 
            const fsSource = `
                varying lowp vec4 vColor;
                varying highp vec3 vLighting; // ** LIGHTING **

                void main(void) {
                    gl_FragColor = vec4(vColor.rgb * vLighting, vColor.a); // ** LIGHTING **
                }
            `;

            // Initialize a shader program; this is where all the lighting
            // for the vertices and so forth is established.
            const shaderProgram = initShaderProgram(gl, vsSource, fsSource);

            // Collect all the info needed to use the shader program.
            // Look up which attribute our shader program is using
            // for aVertexPosition and look up uniform locations.
            const programInfo = {
                program: shaderProgram,
                attribLocations: {
                    vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
                    vertexNormal: gl.getAttribLocation(shaderProgram, 'aVertexNormal'), // ** LIGHTING **
                    vertexColor: gl.getAttribLocation(shaderProgram, 'aVertexColor'),
                },
                uniformLocations: {
                    projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),
                    modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),
                    normalMatrix: gl.getUniformLocation(shaderProgram, 'uNormalMatrix'), // ** LIGHTING **
                }
            };

            // coordinate to draw box
            const positionsBox = [
                // Front face
                -1.0, -1.0,  1.0, // 0
                1.0, -1.0,  1.0, // 1
                1.0,  1.0,  1.0, // 2
                -1.0,  1.0,  1.0, // 3

                // Back face
                -1.0, -1.0, -1.0, // 4
                -1.0,  1.0, -1.0, // 5
                1.0,  1.0, -1.0, // 6
                1.0, -1.0, -1.0, // 7

                // Top face
                -1.0,  1.0, -1.0, // 8
                -1.0,  1.0,  1.0, // 9
                1.0,  1.0,  1.0, // 10
                1.0,  1.0, -1.0, // 11

                // Bottom face
                -1.0, -1.0, -1.0, // 12
                1.0, -1.0, -1.0, // 13
                1.0, -1.0,  1.0, // 14
                -1.0, -1.0,  1.0, // 15

                // Right face
                1.0, -1.0, -1.0, // 16
                1.0,  1.0, -1.0, // 17
                1.0,  1.0,  1.0, // 18
                1.0, -1.0,  1.0, // 19

                // Left face
                -1.0, -1.0, -1.0, // 20
                -1.0, -1.0,  1.0, // 21
                -1.0,  1.0,  1.0, // 22
                -1.0,  1.0, -1.0, // 23
            ];

            gl.clearColor(0.0, 0.0, 0.0, 1.0);  // Clear to black, fully opaque
            gl.clearDepth(1.0);                 // Clear everything
            gl.enable(gl.DEPTH_TEST);           // Enable depth testing
            gl.depthFunc(gl.LEQUAL);            // Near things obscure far things

            const fieldOfView = 45 * Math.PI / 180;   // in radians
            const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
            const zNear = 0.1;
            const zFar = 100.0;
            const projectionMatrix = mat4.create();

            // Put perspective matrix into "cameraMatrix" variable
            var cameraMatrix = mat4.perspective(projectionMatrix,
                                fieldOfView,
                                aspect,
                                zNear,
                                zFar);
               
            // Translate and rotate camera                    
            cameraMatrix = mat4.translate(cameraMatrix,cameraMatrix,[0, -1, -30]);   
            cameraMatrix = mat4.rotateX(cameraMatrix,cameraMatrix,40 * 0.0174533);   
                                
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); // Clear the canvas before we start drawing on it.

            // modelViewMatrix declaration (make the drawing after this centered to 0,0,0 origin coordinate)
            let modelViewMatrix = mat4.create(); 
            // Drag mouse to rotateX & rotateY
            mat4.rotateX(modelViewMatrix,modelViewMatrix,rotateX);   
            mat4.rotateY(modelViewMatrix,modelViewMatrix,rotateY);  
            mat4.rotateZ(modelViewMatrix,modelViewMatrix,rotateZ); 

            // DRAW BASE PLATE
            // ###################################################### //
            colorsBuffer = initBuffers(gl,positionsBox,greyColors);
            mat4.scale(modelViewMatrix,modelViewMatrix,[10,0.1,10]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            // Reset modelViewMatrix to draw another object
            modelViewMatrix = mat4.create(); 
            // Drag mouse to rotateX & rotateY
            mat4.rotateX(modelViewMatrix,modelViewMatrix,rotateX);   
            mat4.rotateY(modelViewMatrix,modelViewMatrix,rotateY);  
            mat4.rotateZ(modelViewMatrix,modelViewMatrix,rotateZ); 

            // DRAW LAKE
            // ###################################################### //
            // Declare colorsBuffer & initialize it
            var colorsBuffer = initBuffers(gl,positionsBox,lakeColors);
            mat4.translate(modelViewMatrix,modelViewMatrix,[0,0.1,0]);
            mat4.scale(modelViewMatrix,modelViewMatrix,[3.8,0.1,6]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            mat4.translate(modelViewMatrix,modelViewMatrix,[-1.5,0,0.3]);
            mat4.scale(modelViewMatrix,modelViewMatrix,[0.7,1,0.5]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            mat4.translate(modelViewMatrix,modelViewMatrix,[4,0,-1.8]);
            mat4.scale(modelViewMatrix,modelViewMatrix,[0.5,1,0.5]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);
            // ###################################################### //

            // Reset modelViewMatrix to draw another object
            modelViewMatrix = mat4.create(); 
            // Drag mouse to rotateX & rotateY
            mat4.rotateX(modelViewMatrix,modelViewMatrix,rotateX);   
            mat4.rotateY(modelViewMatrix,modelViewMatrix,rotateY);  
            mat4.rotateZ(modelViewMatrix,modelViewMatrix,rotateZ); 

            // DRAW TREE 
            // ###################################################### //
            // DRAW TREE 1
            colorsBuffer = initBuffers(gl,positionsBox,brownColors); // TRUNK
            mat4.translate(modelViewMatrix,modelViewMatrix,[5,1.3,-5.3]);
            mat4.scale(modelViewMatrix,modelViewMatrix,[0.3,1,0.3]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            colorsBuffer = initBuffers(gl,positionsBox,leafColors); // LEAF
            mat4.translate(modelViewMatrix,modelViewMatrix,[0,1.5,0]);
            mat4.scale(modelViewMatrix,modelViewMatrix,[2.5,1,3]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            mat4.translate(modelViewMatrix,modelViewMatrix,[-0.3,1,-0.2]);
            mat4.scale(modelViewMatrix,modelViewMatrix,[0.5,0.5,0.5]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            // Reset modelViewMatrix to draw another object
            modelViewMatrix = mat4.create(); 
            // Drag mouse to rotateX & rotateY
            mat4.rotateX(modelViewMatrix,modelViewMatrix,rotateX);   
            mat4.rotateY(modelViewMatrix,modelViewMatrix,rotateY);  
            mat4.rotateZ(modelViewMatrix,modelViewMatrix,rotateZ); 

             // DRAW TREE 2
            colorsBuffer = initBuffers(gl,positionsBox,brownColors); // TRUNK
            mat4.translate(modelViewMatrix,modelViewMatrix,[-4.5,0.7,-4]);
            mat4.scale(modelViewMatrix,modelViewMatrix,[0.3,0.7,0.3]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            colorsBuffer = initBuffers(gl,positionsBox,leafColors); // LEAF
            mat4.translate(modelViewMatrix,modelViewMatrix,[0,1.5,0]);
            mat4.scale(modelViewMatrix,modelViewMatrix,[2.5,1,3]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            mat4.translate(modelViewMatrix,modelViewMatrix,[-0.3,1,-0.2]);
            mat4.scale(modelViewMatrix,modelViewMatrix,[0.5,0.5,0.5]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            // Reset modelViewMatrix to draw another object
            modelViewMatrix = mat4.create(); 
            // Drag mouse to rotateX & rotateY
            mat4.rotateX(modelViewMatrix,modelViewMatrix,rotateX);   
            mat4.rotateY(modelViewMatrix,modelViewMatrix,rotateY);  
            mat4.rotateZ(modelViewMatrix,modelViewMatrix,rotateZ); 

             // DRAW TREE 3
            colorsBuffer = initBuffers(gl,positionsBox,brownColors); // TRUNK
            mat4.translate(modelViewMatrix,modelViewMatrix,[-5.5,1,-2]);
            mat4.scale(modelViewMatrix,modelViewMatrix,[0.3,1,0.3]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            colorsBuffer = initBuffers(gl,positionsBox,leafColors); // LEAF
            mat4.translate(modelViewMatrix,modelViewMatrix,[0,1.5,0]);
            mat4.scale(modelViewMatrix,modelViewMatrix,[2.5,1,3]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            mat4.translate(modelViewMatrix,modelViewMatrix,[-0.3,1,-0.2]);
            mat4.scale(modelViewMatrix,modelViewMatrix,[0.5,0.5,0.5]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            // DRAW BUSH 1
            colorsBuffer = initBuffers(gl,positionsBox,leafColors); // LEAF
            mat4.translate(modelViewMatrix,modelViewMatrix,[0,-5,16.7]);
            mat4.scale(modelViewMatrix,modelViewMatrix,[1,1,1]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            // DRAW BUSH 2
            mat4.translate(modelViewMatrix,modelViewMatrix,[-1.5,-0.5,0.6]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            // Reset modelViewMatrix to draw another object
            modelViewMatrix = mat4.create(); 
            // Drag mouse to rotateX & rotateY
            mat4.rotateX(modelViewMatrix,modelViewMatrix,rotateX);   
            mat4.rotateY(modelViewMatrix,modelViewMatrix,rotateY);  
            mat4.rotateZ(modelViewMatrix,modelViewMatrix,rotateZ); 

             // DRAW TRUNK
            colorsBuffer = initBuffers(gl,positionsBox,brownColors);
            mat4.translate(modelViewMatrix,modelViewMatrix,[3.5,3.5,6]);
            mat4.scale(modelViewMatrix,modelViewMatrix,[0.3,0.7,0.3]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);
            // ###################################################### //

            // Reset modelViewMatrix to draw another object
            modelViewMatrix = mat4.create(); 
            // Drag mouse to rotateX & rotateY
            mat4.rotateX(modelViewMatrix,modelViewMatrix,rotateX);   
            mat4.rotateY(modelViewMatrix,modelViewMatrix,rotateY);  
            mat4.rotateZ(modelViewMatrix,modelViewMatrix,rotateZ); 

            // DRAW STONE
            // ###################################################### //
            colorsBuffer = initBuffers(gl,positionsBox,darkGreyColors);
            mat4.translate(modelViewMatrix,modelViewMatrix,[3,1.5,5.5]);
            mat4.scale(modelViewMatrix,modelViewMatrix,[1.3,1.5,1.2]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            mat4.translate(modelViewMatrix,modelViewMatrix,[1,-0.5,0.5]);
            mat4.rotateY(modelViewMatrix,modelViewMatrix,30 * 0.0174533);  
            mat4.scale(modelViewMatrix,modelViewMatrix,[-0.7,0.5,-0.7]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            mat4.translate(modelViewMatrix,modelViewMatrix,[2.5,0.3,1.5]);
            mat4.rotateY(modelViewMatrix,modelViewMatrix,-10 * 0.0174533);  
            mat4.scale(modelViewMatrix,modelViewMatrix,[1,1.3,1]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            modelViewMatrix = mat4.create(); 
            // Drag mouse to rotateX & rotateY
            mat4.rotateX(modelViewMatrix,modelViewMatrix,rotateX);   
            mat4.rotateY(modelViewMatrix,modelViewMatrix,rotateY);  
            mat4.rotateZ(modelViewMatrix,modelViewMatrix,rotateZ); 

            mat4.translate(modelViewMatrix,modelViewMatrix,[5,0.3,-5]);
            mat4.rotateY(modelViewMatrix,modelViewMatrix,-10 * 0.0174533);  
            mat4.scale(modelViewMatrix,modelViewMatrix,[1.5,0.3,1]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            modelViewMatrix = mat4.create(); 
            // Drag mouse to rotateX & rotateY
            mat4.rotateX(modelViewMatrix,modelViewMatrix,rotateX);   
            mat4.rotateY(modelViewMatrix,modelViewMatrix,rotateY);  
            mat4.rotateZ(modelViewMatrix,modelViewMatrix,rotateZ); 

            mat4.translate(modelViewMatrix,modelViewMatrix,[-6,0.4,5.5]);
            mat4.rotateY(modelViewMatrix,modelViewMatrix,10 * 0.0174533);  
            mat4.scale(modelViewMatrix,modelViewMatrix,[1.5,0.4,0.9]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);
            // ###################################################### //

            // Reset modelViewMatrix to draw another object
            modelViewMatrix = mat4.create(); 
            // Drag mouse to rotateX & rotateY
            mat4.rotateX(modelViewMatrix,modelViewMatrix,rotateX);   
            mat4.rotateY(modelViewMatrix,modelViewMatrix,rotateY);  
            mat4.rotateZ(modelViewMatrix,modelViewMatrix,rotateZ); 

            // DRAW HELI
            // ###################################################### //
            // DRAW HELI BASE
            colorsBuffer = initBuffers(gl,positionsBox,heliColor);
            mat4.rotateY(modelViewMatrix,modelViewMatrix,-heliMove);    // Rotate heli towards 0,0 pivot 

            // Do this first before rotating towards the pivot
            mat4.translate(modelViewMatrix,modelViewMatrix,[7,8,0]);        
            let rotorMatrix = mat4.clone(modelViewMatrix); // clone for later "DRAW HELI ROTOR" // Avoid distortion from other scalings         
            mat4.scale(modelViewMatrix,modelViewMatrix,[0.5,0.5,0.7]);              
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            mat4.translate(modelViewMatrix,modelViewMatrix,[0,0.3,-2]);
            mat4.scale(modelViewMatrix,modelViewMatrix,[0.3,0.3,1.3]);    
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            mat4.translate(modelViewMatrix,modelViewMatrix,[0,2,-0.7]);
            mat4.scale(modelViewMatrix,modelViewMatrix,[1,1.3,0.3]);    
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            // DRAW HELI ROTOR using "rotorMatrix"
            colorsBuffer = initBuffers(gl,positionsBox,rotorColor);
            mat4.translate(rotorMatrix,rotorMatrix,[0,0.7,0]); 
            mat4.rotateY(rotorMatrix,rotorMatrix,rotorMove); 
            mat4.scale(rotorMatrix,rotorMatrix,[3,0.05,0.3]);   
            drawScene(gl, programInfo, colorsBuffer, rotorMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);
            // ###################################################### //

            // Reset modelViewMatrix to draw another object
            modelViewMatrix = mat4.create(); 
            // Drag mouse to rotateX & rotateY
            mat4.rotateX(modelViewMatrix,modelViewMatrix,rotateX);   
            mat4.rotateY(modelViewMatrix,modelViewMatrix,rotateY);  
            mat4.rotateZ(modelViewMatrix,modelViewMatrix,rotateZ); 

            // DRAW BOAT
            // ###################################################### //
            colorsBuffer = initBuffers(gl,positionsBox,boatColor);
            mat4.translate(modelViewMatrix,modelViewMatrix,[boatMoveX,0.3,boatMoveZ]);
            mat4.rotateY(modelViewMatrix,modelViewMatrix,boatRotateY * 0.0174533);  
            let boatMatrix = mat4.clone(modelViewMatrix);
            mat4.scale(modelViewMatrix,modelViewMatrix,[0.8,0.3,1]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            // DRAW FRONT
            mat4.translate(boatMatrix,boatMatrix,[0,0,-1]);
            mat4.rotateY(boatMatrix,boatMatrix,45 * 0.0174533);  
            mat4.scale(boatMatrix,boatMatrix,[0.4,0.2,0.4]);
            drawScene(gl, programInfo, colorsBuffer, boatMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            // DRAW BACK
            mat4.translate(boatMatrix,boatMatrix,[-3.5,0,3.5]);
            drawScene(gl, programInfo, colorsBuffer, boatMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            // DRAW POLL
            colorsBuffer = initBuffers(gl,positionsBox,darkGreyColors);
            mat4.translate(modelViewMatrix,modelViewMatrix,[0,5,0]);
            mat4.scale(modelViewMatrix,modelViewMatrix,[0.1,5,0.1]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            // DRAW FLAG
            colorsBuffer = initBuffers(gl,positionsBox,flagColor);
            mat4.rotateY(modelViewMatrix,modelViewMatrix,flagMove); // Rotate towards original origin
            mat4.translate(modelViewMatrix,modelViewMatrix,[0,0.5,5]);
            mat4.scale(modelViewMatrix,modelViewMatrix,[0.1,0.5,5]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

        }
        
        // Array for variance of greyColors
        var greyColors = [   
            [0.7,  0.7,  0.7, 1.0],    
            [0.7,  0.7,  0.7, 1.0],    
            [0.7,  0.7,  0.7, 1.0],    
            [0.7,  0.7,  0.7, 1.0],    
            [0.7,  0.7,  0.7, 1.0],       
            [0.7,  0.7,  0.7, 1.0],      
            [0.7,  0.7,  0.7, 1.0],    
        ];

        var darkGreyColors = [   
            [0.569, 0.569, 0.569, 1.0],  
            [0.569, 0.569, 0.569, 1.0],  
            [0.569, 0.569, 0.569, 1.0],  
            [0.569, 0.569, 0.569, 1.0],  
            [0.569, 0.569, 0.569, 1.0],  
            [0.569, 0.569, 0.569, 1.0],  
        ];

        var greenColors = [ 
            [0, 0.990, 0.990, 1.0],    
            [0, 0.990, 0.990, 1.0],   
            [0, 0.880, 0.880, 1.0],   
            [0, 0.880, 0.880, 1.0],   
            [0, 0.770, 0.770, 1.0],   
            [0, 0.770, 0.770, 1.0],   
        ];

        var pinkColors = [ 
            [0.990, 0, 0.5, 1.0],    
            [0.990, 0, 0.5, 1.0],    
            [0.990, 0, 0.5, 1.0],    
            [0.990, 0, 0.5, 1.0],    
            [0.990, 0, 0.5, 1.0],    
            [0.990, 0, 0.5, 1.0],    
        ];

        var lakeColors = [
            [0.702, 0.929, 1, 1.0],
            [0.702, 0.929, 1, 1.0],
            [0.459, 0.871, 1, 1.0],
            [0.702, 0.929, 1, 1.0],
            [0.702, 0.929, 1, 1.0],
            [0.702, 0.929, 1, 1.0],
        ];

        var brownColors = [
            [0.62, 0.4, 0, 1.0],
            [0.62, 0.4, 0, 1.0],
            [0.62, 0.4, 0, 1.0],
            [0.62, 0.4, 0, 1.0],
            [0.62, 0.4, 0, 1.0],
            [0.62, 0.4, 0, 1.0],
        ];

        var leafColors = [
            [0.051, 1, 0, 1.0],
            [0.051, 1, 0, 1.0],
            [0.051, 1, 0, 1.0],
            [0.051, 1, 0, 1.0],
            [0.051, 1, 0, 1.0],
            [0.051, 1, 0, 1.0],
        ];

        var orangeColors = [
            [1, 0.812, 0, 1.0],
            [1, 0.812, 0, 1.0],
            [1, 0.812, 0, 1.0],
            [1, 0.812, 0, 1.0],
            [1, 0.812, 0, 1.0],
            [1, 0.812, 0, 1.0],
        ];

        var blueColors = [
            [0, 0, 1, 1.0],
            [0, 0, 1, 1.0],
            [0, 0, 1, 1.0],
            [0, 0, 1, 1.0],
            [0, 0, 1, 1.0],
            [0, 0, 1, 1.0],
        ];

        var redColors = [
            [1, 0, 0, 1.0],
            [1, 0, 0, 1.0],
            [1, 0, 0, 1.0],
            [1, 0, 0, 1.0],
            [1, 0, 0, 1.0],
            [1, 0, 0, 1.0],
        ];

        var rotateX = 0, rotateY = 0, rotateZ = 0;

        // Mouse drag to rotateX & rotateY
        // *******************************
        var prevx, prevy, canvas;
        var dragging = false;

        function doMouseDown(evt) {
            if (dragging)
                return;
            dragging = true;
            document.addEventListener("mousemove", doMouseDrag, false);
            document.addEventListener("mouseup", doMouseUp, false);
            var box = canvas.getBoundingClientRect();
            prevx = window.pageXOffset + evt.clientX - box.left;
            prevy = window.pageYOffset + evt.clientY - box.top;
        }

        function doMouseDrag(evt) {
            if (!dragging)
                return;
            var box = canvas.getBoundingClientRect();
            var x = window.pageXOffset + evt.clientX - box.left;
            var y = window.pageYOffset + evt.clientY - box.top;
            let diffy = (prevx - x) * 0.01;
            let diffx = (prevy - y) * 0.01;
            prevx = x;
            prevy = y;
            rotateX = rotateX - diffx;
            rotateY = rotateY - diffy;
            main();
        }
        
        function doMouseUp(evt) {
            if (dragging) {
                document.removeEventListener("mousemove", doMouseDrag, false);
                document.removeEventListener("mouseup", doMouseUp, false);
                dragging = false;
            }
        }
        
        function resetRotation() {
            rotateX = 0, rotateY = 0, rotateZ = 0;
            main();
        }
        // *******************************
        
        window.onload = main;

        // ########################################### //
        // initBuffers 
        //
        // Initialize the buffers we'll need. For this demo, we just
        // have one object -- a simple three-dimensional cube.
        //
        function initBuffers(gl,positions,faceColors) {

            // Create a buffer for the square's positions.
            const positionBuffer = gl.createBuffer();

            // Select the positionBuffer as the one to apply buffer
            // operations to from here out.
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

            // Now pass the list of positions into WebGL to build the
            // shape. We do this by creating a Float32Array from the
            // JavaScript array, then use it to fill the current buffer.
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

            // ** LIGHTING **
            // Set up the normals for the vertices, so that we can compute lighting.
            const normalBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);

            // ** LIGHTING **
            const vertexNormals = [
                // Front
                0.0,  0.0,  1.0,
                0.0,  0.0,  1.0,
                0.0,  0.0,  1.0,
                0.0,  0.0,  1.0,

                // Back
                0.0,  0.0, -1.0,
                0.0,  0.0, -1.0,
                0.0,  0.0, -1.0,
                0.0,  0.0, -1.0,

                // Top
                0.0,  1.0,  0.0,
                0.0,  1.0,  0.0,
                0.0,  1.0,  0.0,
                0.0,  1.0,  0.0,

                // Bottom
                0.0, -1.0,  0.0,
                0.0, -1.0,  0.0,
                0.0, -1.0,  0.0,
                0.0, -1.0,  0.0,

                // Right
                1.0,  0.0,  0.0,
                1.0,  0.0,  0.0,
                1.0,  0.0,  0.0,
                1.0,  0.0,  0.0,

                // Left
                -1.0,  0.0,  0.0,
                -1.0,  0.0,  0.0,
                -1.0,  0.0,  0.0,
                -1.0,  0.0,  0.0
            ];

            // ** LIGHTING **
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexNormals), gl.STATIC_DRAW);

            // Color buffer                
            var colors = [];

            for (var j = 0; j < faceColors.length; ++j) {
                const c = faceColors[j];
                colors = colors.concat(c, c, c, c);
            }

            const colorBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);

            // Build the element array buffer; this specifies the indices
            // into the vertex arrays for each face's vertices.
            const indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);

            // This array defines each face as two triangles, using the
            // indices into the vertex array to specify each triangle's
            // position.
            const indices = [
                0,  1,  2,      0,  2,  3,    // front
                4,  5,  6,      4,  6,  7,    // back
                8,  9,  10,     8,  10, 11,   // top
                12, 13, 14,     12, 14, 15,   // bottom
                16, 17, 18,     16, 18, 19,   // right
                20, 21, 22,     20, 22, 23,   // left
            ];

            // Now send the element array to GL

            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

            return {
                position: positionBuffer,
                normal: normalBuffer, // ** LIGHTING **
                color: colorBuffer,
                indices: indexBuffer,
            };
        }

        // ########################################### //
        // Draw the scene.
        //
        function drawScene(gl, programInfo, buffers, modelViewMatrix, projectionMatrix) {
            // Tell WebGL how to pull out the positions from the position
            // buffer into the vertexPosition attribute.
            {
                const numComponents = 3; // (x,y,z)
                const type = gl.FLOAT;
                const normalize = false;
                const stride = 0;
                const offset = 0;
                gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
                gl.vertexAttribPointer(
                    programInfo.attribLocations.vertexPosition,
                    numComponents,
                    type,
                    normalize,
                    stride,
                    offset);
                gl.enableVertexAttribArray(
                    programInfo.attribLocations.vertexPosition);
            }

            // Tell WebGL how to pull out the colors from the color buffer
            // into the vertexColor attribute.
            {
                const numComponents = 4; // (r,g,b,a)
                const type = gl.FLOAT;
                const normalize = false;
                const stride = 0;
                const offset = 0;
                gl.bindBuffer(gl.ARRAY_BUFFER, buffers.color);
                gl.vertexAttribPointer(
                    programInfo.attribLocations.vertexColor,
                    numComponents,
                    type,
                    normalize,
                    stride,
                    offset);
                gl.enableVertexAttribArray(
                    programInfo.attribLocations.vertexColor);
            }

            // ** LIGHTING ** Start ---
            var normalMatrix = mat4.create();
            mat4.invert(normalMatrix, modelViewMatrix);
            mat4.transpose(normalMatrix, normalMatrix);

            // Tell WebGL how to pull out the normals from
            // the normal buffer into the vertexNormal attribute.
            {
                const numComponents = 3; // (x, y, z)
                const type = gl.FLOAT;
                const normalize = false;
                const stride = 0;
                const offset = 0;
                gl.bindBuffer(gl.ARRAY_BUFFER, buffers.normal);
                gl.vertexAttribPointer(
                    programInfo.attribLocations.vertexNormal,
                    numComponents,
                    type,
                    normalize,
                    stride,
                    offset);
                gl.enableVertexAttribArray(
                    programInfo.attribLocations.vertexNormal);
            }    
            // ** LIGHTING ** Finish ---

            // Tell WebGL which indices to use to index the vertices
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices);

            // Tell WebGL to use our program when drawing
            gl.useProgram(programInfo.program);

            // Set the shader uniforms
            gl.uniformMatrix4fv(
                programInfo.uniformLocations.projectionMatrix,
                false,
                projectionMatrix);
            gl.uniformMatrix4fv(
                programInfo.uniformLocations.modelViewMatrix,
                false,
                modelViewMatrix);

            // ** LIGHTING **    
            gl.uniformMatrix4fv(
                programInfo.uniformLocations.normalMatrix,
                false,
                normalMatrix);
        }

        // ########################################### //
        // Initialize a shader program, so WebGL knows how to draw our data
        //
        function initShaderProgram(gl, vsSource, fsSource) {
            const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
            const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

            // Create the shader program
            const shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);

            // If creating the shader program failed, alert
            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
                return null;
            }

            return shaderProgram;
        }

        // ########################################### //
        // creates a shader of the given type, uploads the source and
        // compiles it.
        //
        function loadShader(gl, type, source) {
            const shader = gl.createShader(type);

            // Send the source to the shader object
            gl.shaderSource(shader, source);

            // Compile the shader program
            gl.compileShader(shader);

            // See if it compiled successfully
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }

            return shader;
        }

        // ########################################### //
        // CAMERA & PROJECTION functions
        // ########################################### //

        // Reset camera
        function resetCamera() {
            
        }
        
        // Field of view
        function changeC1value() {
            
        }

        // Camera rotate-x
        function changeC2value() {
            
        }

        // z-Position
        function changeC3value() {
            
        }

        // ########################################### //
        // HELI TRANSFORMATION & COLOR functions
        // ########################################### //

        var heliBool = true, heliMove = 0, heliSpeed = 1;
        var timer = setInterval(function(){ animateHeliMoveLoop() }, 10);

        function stopParent1() {
            if (heliBool == true) { heliBool = false; }
            else { heliBool = true; }

            if (heliBool == true) {
                timer = setInterval(function(){ animateHeliMoveLoop() }, 10);
                document.getElementById("stopParent1").value = "Stop Parent 1";
            } else {
                clearInterval(timer);
                document.getElementById("stopParent1").value = "Start Parent 1";
            }
        }

        function animateHeliMoveLoop() {
            if (heliMove > 360) { heliMove = 0; }
            else { heliMove = heliMove + (heliSpeed * 0.0174533);  }
            main();
        }

        function speedParent1() {
            heliSpeed = document.getElementById("speedParent1").value; 
            document.getElementById("sP1Label").innerHTML = heliSpeed;
        }

        var heliRotorBool = true, rotorMove = 0, rotorSpeed = 50;
        var timer2 = setInterval(function(){ animateRotorMoveLoop() }, 10);

        function stopChild1() {
            if (heliRotorBool == true) { heliRotorBool = false; }
            else { heliRotorBool = true; }

            if (heliRotorBool == true) {
                timer2 = setInterval(function(){ animateRotorMoveLoop() }, 10);
                document.getElementById("stopChild1").value = "Stop Child 1";
            } else {
                clearInterval(timer2);
                document.getElementById("stopChild1").value = "Start Child 1";
            }
        }

        function animateRotorMoveLoop() {
            if (rotorMove > 360) { rotorMove = 0; }
            else { rotorMove = rotorMove + (rotorSpeed * 0.0174533);  }
            main();
        }

        function speedChild1() {
            rotorSpeed = document.getElementById("speedChild1").value; 
            document.getElementById("sC1Label").innerHTML = rotorSpeed;
        }

        var heliColor = pinkColors, heliColorBool = true;
        function colorParent1() {
            if (heliColorBool == true) { heliColorBool = false; } 
            else { heliColorBool = true; }

            alphaParent1(); 
            main();
        }

        var rotorColor = darkGreyColors, rotorColorBool = true;
        function colorChild1() {
            if (rotorColorBool == true) { rotorColorBool = false; } 
            else { rotorColorBool = true; }

            if (rotorColorBool == true) { rotorColor = darkGreyColors; }
            else { rotorColor = greenColors; }

            main();
        }

        var alphaP1Value = 1;
        function alphaParent1() {
            alphaP1Value = document.getElementById("alphaParent1").value / 10; 
            document.getElementById("aP1Label").innerHTML = parseFloat(alphaP1Value).toFixed(1);;

            if (heliColorBool == true) {
                heliColor = [ // pinkColors
                    [0.990, 0, 0.5, alphaP1Value],    
                    [0.990, 0, 0.5, alphaP1Value],    
                    [0.990, 0, 0.5, alphaP1Value],    
                    [0.990, 0, 0.5, alphaP1Value],    
                    [0.990, 0, 0.5, alphaP1Value],    
                    [0.990, 0, 0.5, alphaP1Value],    
                ];
            } else { 
                heliColor = [ // blueColors
                    [0, 0, 1, alphaP1Value],    
                    [0, 0, 1, alphaP1Value],    
                    [0, 0, 1, alphaP1Value],    
                    [0, 0, 1, alphaP1Value],    
                    [0, 0, 1, alphaP1Value],    
                    [0, 0, 1, alphaP1Value],     
                ];
            }

            main();
        }

        // ########################################### //
        // BOAT TRANSFORMATION & COLOR functions
        // ########################################### //

        var boatBool = true, forwardBool = true, boatRotateY = -60;
        var boatMoveX = -6, boatMoveZ = 2.5, boatSpeedX = 0.005, boatSpeedZ = 0.003, boatSpeedVar = 1;
        var timer3 = setInterval(function(){ animateBoatMoveLoop() }, 10);

        function stopParent2() {
            if (boatBool == true) { boatBool = false; }
            else { boatBool = true; }

            if (boatBool == true) {
                timer3 = setInterval(function(){ animateBoatMoveLoop() }, 10);
                document.getElementById("stopParent2").value = "Stop Parent 2";
            } else {
                clearInterval(timer3);
                document.getElementById("stopParent2").value = "Start Parent 2";
            }
        }

        function animateBoatMoveLoop() {
            if (boatMoveX > 2.07) {
                forwardBool = false;
                boatRotateY = 120;
            } else if (boatMoveX < -5.98) {
                forwardBool = true;
                boatRotateY = -60;
            }

            if (forwardBool == true) {
                boatMoveX += boatSpeedX * boatSpeedVar;
                boatMoveZ -= boatSpeedZ * boatSpeedVar;
            } else {
                boatMoveX -= boatSpeedX * boatSpeedVar;
                boatMoveZ += boatSpeedZ * boatSpeedVar;
            }
            main();
        }

        function speedParent2() {
            boatSpeedVar = document.getElementById("speedParent2").value; 
            document.getElementById("sP2Label").innerHTML = boatSpeedVar;
        }

        var flagBool = true, flagFlipBool = true, flagMove = -1, flagSpeed = 1;
        var timer4 = setInterval(function(){ animateFlagMoveLoop() }, 10);

        function stopChild2() {
            if (flagBool == true) { flagBool = false; }
            else { flagBool = true; }

            if (flagBool == true) {
                timer4 = setInterval(function(){ animateFlagMoveLoop() }, 10);
                document.getElementById("stopChild2").value = "Stop Child 2";
            } else {
                clearInterval(timer4);
                document.getElementById("stopChild2").value = "Start Child 2";
            }
        }

        function animateFlagMoveLoop() {
            if (flagMove <= -1) { flagFlipBool = true; }
            else if (flagMove >= 1) { flagFlipBool = false; }

            if (flagFlipBool == true) { flagMove += (flagSpeed * 0.0174533); }
            else { flagMove -= (flagSpeed * 0.0174533); }

            main();
        }

        function speedChild2() {
            flagSpeed = document.getElementById("speedChild2").value; 
            document.getElementById("sC2Label").innerHTML = flagSpeed;
        }

        var boatColor = orangeColors, boatColorBool = true;
        function colorParent2() {
            if (boatColorBool == true) { boatColorBool = false; } 
            else { boatColorBool = true; }

            alphaParent2(); 
            main();
        }

        var flagColor = blueColors, flagColorBool = true;
        function colorChild2() {
            if (flagColorBool == true) { flagColorBool = false; } 
            else { flagColorBool = true; }

            if (flagColorBool == true) { flagColor = blueColors; }
            else { flagColor = redColors; }

            main();
        }

        var alphaP2Value = 1;
        function alphaParent2() {
            alphaP2Value = document.getElementById("alphaParent2").value / 10; 
            document.getElementById("aP2Label").innerHTML = parseFloat(alphaP2Value).toFixed(1);;

            if (boatColorBool == true) {
                boatColor = [ // orangeColors
                    [1, 0.812, 0, alphaP2Value],
                    [1, 0.812, 0, alphaP2Value],
                    [1, 0.812, 0, alphaP2Value],
                    [1, 0.812, 0, alphaP2Value],
                    [1, 0.812, 0, alphaP2Value],
                    [1, 0.812, 0, alphaP2Value],
                ];
            } else {
                boatColor = [ // pinkColors
                    [0.990, 0, 0.5, alphaP2Value],    
                    [0.990, 0, 0.5, alphaP2Value],   
                    [0.990, 0, 0.5, alphaP2Value],   
                    [0.990, 0, 0.5, alphaP2Value],   
                    [0.990, 0, 0.5, alphaP2Value],   
                    [0.990, 0, 0.5, alphaP2Value],   
                ];
            }

            main();
        }
    </script>
    <style>
        .sceneLabel {
            background-color: #e1e1e1;
            padding: 7px 10px 7px 10px; 
            margin: 7px 5px 0px 5px;
            font-size: 0.9em;
            font-weight: bold;
            -webkit-border-radius: 5px;
            display: inline-block;
            width: auto;
        }
        .objLabel {
            background-color: #e1e1e1;
            padding: 7px 10px 7px 10px; 
            margin: 5px 5px 15px 5px;
            font-size: 0.8em;
            font-weight: bold;
            -webkit-border-radius: 5px;
            display: inline-block;
            width: auto;
        }
        td { font-size: 0.9em; }
    </style>
</head>

<body style="font-family: Arial, Helvetica, sans-serif; text-align: center; font-size: 0.9em;">
    <div style="padding: 10px 0px 5px 0px;">
        <div style="padding-bottom:7px;">Drag mouse inside canvas to rotate ALL OBJECTS on x-axis and y-axis</div>
        <input type="button" id="resetBtn" value="Reset rotation" onclick="resetRotation()">
        <br><div class="sceneLabel">Forest scene: Lake, tree/bush, rock, boat and helicopter</div>
    </div>
    <canvas id="glCanvas" width="640" height="480"></canvas>
    <table width="640" cellpadding="0" cellspacing="5" border="0" align="center">
        <tr><td colspan="2" align="center" style="padding: 5px;">
            <b>CAMERA & PROJECTION</b>&nbsp;&nbsp;
            <input type="button" id="resetCamBtn" value="Reset camera" onclick="resetCamera()">
        </td></tr>
        <tr>
            <td width="30%" align="right">Field of view: <span id="c1Label">45&deg;</span></td>
            <td><input oninput="changeC1value()" id="c1Value" type="range" min="0" max="180" value="45" style="width: 100%"></td>
        </tr>
        <tr>
            <td width="" align="right">Rotate-x (camera): <span id="c2Label">40&deg;</span></td>
            <td><input oninput="changeC2value()" id="c2Value" type="range" min="0" max="100" value="40" style="width: 100%"></td>
        </tr>
        <tr>
            <td width="" align="right">z-Position (camera): <span id="c3Label">30</span></td>
            <td><input oninput="changeC3value()" id="c3Value" type="range" min="0" max="100" value="30" style="width: 100%"></td>
        </tr>
        <tr><td colspan="2"><hr></td></tr>
    </table>
    <div><b>OBJECT TRANSFORMATION & COLOR</b></div>
    <table width="640" cellpadding="0" cellspacing="5" border="0" align="center">  
        <tr>
            <td align="center">
                <div class="objLabel">CD12345 ABBAS: Helicopter</div><br>
                <input type="button" id="stopParent1" value="Stop Parent 1" onclick="stopParent1()" style="margin-bottom: 5px;">
                &nbsp;[ <span id="sP1Label">1</span> ]
                <br><input oninput="speedParent1()" id="speedParent1" type="range" min="1" max="10" value="1" style="width: 80%">
                <hr width="80%">
                <input type="button" id="stopChild1" value="Stop Child 1" onclick="stopChild1()" style="margin-bottom: 5px;">
                &nbsp;[ <span id="sC1Label">30</span> ]
                <br><input oninput="speedChild1()" id="speedChild1" type="range" min="1" max="100" value="30" style="width: 80%">
                <hr width="80%">
                RGB[A: <span id="aP1Label">1.0</span>]&nbsp; 
                <input type="button" id="colorParent1" value="Parent 1" onclick="colorParent1()" style="margin-bottom: 5px;">
                <input type="button" id="colorChild1" value="Child 1" onclick="colorChild1()" style="margin-bottom: 5px;">
                <br><input oninput="alphaParent1()" id="alphaParent1" type="range" min="0" max="10" value="10" style="width: 80%">
            </td>
            <td align="center">
                <div class="objLabel">CD54321 SALIIMI: Boat</div><br>
                <input type="button" id="stopParent2" value="Stop Parent 2" onclick="stopParent2()" style="margin-bottom: 5px;">
                &nbsp;[ <span id="sP2Label">1</span> ]
                <br><input oninput="speedParent2()" id="speedParent2" type="range" min="1" max="10" value="1" style="width: 80%">
                <hr width="80%">
                <input type="button" id="stopChild2" value="Stop Child 2" onclick="stopChild2()" style="margin-bottom: 5px;">
                &nbsp;[ <span id="sC2Label">1</span> ]
                <br><input oninput="speedChild2()" id="speedChild2" type="range" min="1" max="10" value="1" style="width: 80%">
                <hr width="80%">
                RGB[A: <span id="aP2Label">1.0</span>]&nbsp; 
                <input type="button" id="colorParent2" value="Parent 2" onclick="colorParent2()" style="margin-bottom: 5px;">
                <input type="button" id="colorChild2" value="Child 2" onclick="colorChild2()" style="margin-bottom: 5px;">
                <br><input oninput="alphaParent2()" id="alphaParent2" type="range" min="0" max="10" value="10" style="width: 80%">
            </td>
            <!-- UNCOMMENTS FOR OTHER MEMBERS -->
            <!-- <td align="center">
                <div class="objLabel">CD0000 NAME: Object name</div><br>
                <input type="button" id="stopParent3" value="Stop Parent 3" onclick="stopParent3()" style="margin-bottom: 5px;">
                &nbsp;[ <span id="sP3Label">1</span> ]
                <br><input oninput="speedParent3()" id="speedParent3" type="range" min="1" max="10" value="1" style="width: 80%">
                <hr width="80%">
                <input type="button" id="stopChild3" value="Stop Child 3" onclick="stopChild3()" style="margin-bottom: 5px;">
                &nbsp;[ <span id="sC3Label">1</span> ]
                <br><input oninput="speedChild3()" id="speedChild3" type="range" min="1" max="10" value="1" style="width: 80%">
                <hr width="80%">
                RGB[A: <span id="aP3Label">1.0</span>]&nbsp; 
                <input type="button" id="colorParent3" value="Parent 3" onclick="colorParent3()" style="margin-bottom: 5px;">
                <input type="button" id="colorChild3" value="Child 3" onclick="colorChild3()" style="margin-bottom: 5px;">
                <br><input oninput="alphaParent3()" id="alphaParent3" type="range" min="0" max="10" value="10" style="width: 80%">
            </td> -->
        </tr> 
    </table>
</body>