<head>
    <script src="gl-matrix-min.js"></script>
    <script>
        function main() {
            canvas = document.querySelector("#glCanvas");
            canvas.addEventListener("mousedown", doMouseDown, false);
            // Initialize the GL context
            const gl = canvas.getContext("webgl");
        
            // Only continue if WebGL is available and working
            if (gl === null) {
                alert("Unable to initialize WebGL. Your browser or machine may not support it.");
                return;
            }
        
            // Vertex shader program
            const vsSource = `
                attribute vec4 aVertexPosition;
                attribute vec3 aVertexNormal; // ** LIGHTING **
                attribute vec4 aVertexColor;

                uniform mat4 uNormalMatrix; // ** LIGHTING **
                uniform mat4 uModelViewMatrix;
                uniform mat4 uProjectionMatrix;

                varying lowp vec4 vColor;
                varying highp vec3 vLighting; // ** LIGHTING **

                void main(void) {
                    gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
                    vColor = aVertexColor;

                    // Apply lighting effect // ** LIGHTING **

                    highp vec3 ambientLight = vec3(0.15, 0.15, 0.15); // ambient light
                    highp vec3 directionalLightColor = vec3(0.45, 0.45, 0.45); // light color // (1, 1, 1) is full white
                    highp vec3 directionalVector = normalize(vec3(0.85, 0.4, 0.75));

                    highp vec4 transformedNormal = uNormalMatrix * vec4(aVertexNormal, 1.0);

                    highp float directional = max(dot(transformedNormal.xyz, directionalVector), 0.0);
                    vLighting = ambientLight + (directionalLightColor * directional);
                    //vLighting = ambientLight;
                    //vLighting = directionalLightColor * directional;
                }
            `;

            // Fragment shader program 
            const fsSource = `
                varying lowp vec4 vColor;
                varying highp vec3 vLighting; // ** LIGHTING **

                void main(void) {
                    gl_FragColor = vec4(vColor.rgb * vLighting, vColor.a); // ** LIGHTING **
                }
            `;

            // Initialize a shader program; this is where all the lighting
            // for the vertices and so forth is established.
            const shaderProgram = initShaderProgram(gl, vsSource, fsSource);

            // Collect all the info needed to use the shader program.
            // Look up which attribute our shader program is using
            // for aVertexPosition and look up uniform locations.
            const programInfo = {
                program: shaderProgram,
                attribLocations: {
                    vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
                    vertexNormal: gl.getAttribLocation(shaderProgram, 'aVertexNormal'), // ** LIGHTING **
                    vertexColor: gl.getAttribLocation(shaderProgram, 'aVertexColor'),
                },
                uniformLocations: {
                    projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),
                    modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),
                    normalMatrix: gl.getUniformLocation(shaderProgram, 'uNormalMatrix'), // ** LIGHTING **
                }
            };

            // coordinate to draw box
            const positionsBox = [
                // Front face
                -1.0, -1.0,  1.0, // 0
                1.0, -1.0,  1.0, // 1
                1.0,  1.0,  1.0, // 2
                -1.0,  1.0,  1.0, // 3

                // Back face
                -1.0, -1.0, -1.0, // 4
                -1.0,  1.0, -1.0, // 5
                1.0,  1.0, -1.0, // 6
                1.0, -1.0, -1.0, // 7

                // Top face
                -1.0,  1.0, -1.0, // 8
                -1.0,  1.0,  1.0, // 9
                1.0,  1.0,  1.0, // 10
                1.0,  1.0, -1.0, // 11

                // Bottom face
                -1.0, -1.0, -1.0, // 12
                1.0, -1.0, -1.0, // 13
                1.0, -1.0,  1.0, // 14
                -1.0, -1.0,  1.0, // 15

                // Right face
                1.0, -1.0, -1.0, // 16
                1.0,  1.0, -1.0, // 17
                1.0,  1.0,  1.0, // 18
                1.0, -1.0,  1.0, // 19

                // Left face
                -1.0, -1.0, -1.0, // 20
                -1.0, -1.0,  1.0, // 21
                -1.0,  1.0,  1.0, // 22
                -1.0,  1.0, -1.0, // 23
            ];

            gl.clearColor(0.0, 0.0, 0.0, 1.0);  // Clear to black, fully opaque
            gl.clearDepth(1.0);                 // Clear everything
            gl.enable(gl.DEPTH_TEST);           // Enable depth testing
            gl.depthFunc(gl.LEQUAL);            // Near things obscure far things

            //const fieldOfView = 45 * Math.PI / 180;   // in radians
            var fieldOfView = fieldOfViewC1 * 0.0174533;
            const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
            const projectionMatrix = mat4.create();

            // Put perspective matrix into "cameraMatrix" variable
            var cameraMatrix = mat4.perspective(projectionMatrix,
                                fieldOfView,
                                aspect,
                                zNear,
                                zFar);
               
            // Translate and rotate camera                    
            cameraMatrix = mat4.translate(cameraMatrix,cameraMatrix,[0, -1, -30]);   
            cameraMatrix = mat4.rotateX(cameraMatrix,cameraMatrix,40 * 0.0174533);
            cameraMatrix = mat4.translate(cameraMatrix,cameraMatrix,[0, 0, -zPosition]);   


                                
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); // Clear the canvas before we start drawing on it.

            // modelViewMatrix declaration (make the drawing after this centered to 0,0,0 origin coordinate)
            let modelViewMatrix = mat4.create(); 
            // Drag mouse to rotateX & rotateY
            mat4.rotateX(modelViewMatrix,modelViewMatrix,rotateX);   
            mat4.rotateY(modelViewMatrix,modelViewMatrix,rotateY);  
            mat4.rotateZ(modelViewMatrix,modelViewMatrix,rotateZ); 

            // DRAW BASE PLATE
            // ###################################################### //
            colorsBuffer = initBuffers(gl,positionsBox,greyColors);
            mat4.scale(modelViewMatrix,modelViewMatrix,[10,0.1,10]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            // Reset modelViewMatrix to draw another object
            modelViewMatrix = mat4.create(); 
            // Drag mouse to rotateX & rotateY
            mat4.rotateX(modelViewMatrix,modelViewMatrix,rotateX);   
            mat4.rotateY(modelViewMatrix,modelViewMatrix,rotateY);  
            mat4.rotateZ(modelViewMatrix,modelViewMatrix,rotateZ); 

            // DRAW LAKE
            // ###################################################### //
            // Declare colorsBuffer & initialize it
            var colorsBuffer = initBuffers(gl,positionsBox,lakeColors);
            mat4.translate(modelViewMatrix,modelViewMatrix,[0,0.1,0]);
            mat4.scale(modelViewMatrix,modelViewMatrix,[3.8,0.1,6]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            mat4.translate(modelViewMatrix,modelViewMatrix,[-1.5,0,0.3]);
            mat4.scale(modelViewMatrix,modelViewMatrix,[0.7,1,0.5]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            mat4.translate(modelViewMatrix,modelViewMatrix,[4,0,-1.8]);
            mat4.scale(modelViewMatrix,modelViewMatrix,[0.5,1,0.5]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);
            // ###################################################### //

            // Reset modelViewMatrix to draw another object
            modelViewMatrix = mat4.create(); 
            // Drag mouse to rotateX & rotateY
            mat4.rotateX(modelViewMatrix,modelViewMatrix,rotateX);   
            mat4.rotateY(modelViewMatrix,modelViewMatrix,rotateY);  
            mat4.rotateZ(modelViewMatrix,modelViewMatrix,rotateZ); 

            // DRAW TREE 
            // ###################################################### //
            // DRAW TREE 1
            colorsBuffer = initBuffers(gl,positionsBox,brownColors); // TRUNK
            mat4.translate(modelViewMatrix,modelViewMatrix,[5,1.3,-5.3]);
            mat4.scale(modelViewMatrix,modelViewMatrix,[0.3,1,0.3]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            colorsBuffer = initBuffers(gl,positionsBox,leafColors); // LEAF
            mat4.translate(modelViewMatrix,modelViewMatrix,[0,1.5,0]);
            mat4.scale(modelViewMatrix,modelViewMatrix,[2.5,1,3]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            mat4.translate(modelViewMatrix,modelViewMatrix,[-0.3,1,-0.2]);
            mat4.scale(modelViewMatrix,modelViewMatrix,[0.5,0.5,0.5]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            // Reset modelViewMatrix to draw another object
            modelViewMatrix = mat4.create(); 
            // Drag mouse to rotateX & rotateY
            mat4.rotateX(modelViewMatrix,modelViewMatrix,rotateX);   
            mat4.rotateY(modelViewMatrix,modelViewMatrix,rotateY);  
            mat4.rotateZ(modelViewMatrix,modelViewMatrix,rotateZ); 

             // DRAW TREE 2
            colorsBuffer = initBuffers(gl,positionsBox,brownColors); // TRUNK
            mat4.translate(modelViewMatrix,modelViewMatrix,[-4.5,0.7,-4]);
            mat4.scale(modelViewMatrix,modelViewMatrix,[0.3,0.7,0.3]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            colorsBuffer = initBuffers(gl,positionsBox,leafColors); // LEAF
            mat4.translate(modelViewMatrix,modelViewMatrix,[0,1.5,0]);
            mat4.scale(modelViewMatrix,modelViewMatrix,[2.5,1,3]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            mat4.translate(modelViewMatrix,modelViewMatrix,[-0.3,1,-0.2]);
            mat4.scale(modelViewMatrix,modelViewMatrix,[0.5,0.5,0.5]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            // Reset modelViewMatrix to draw another object
            modelViewMatrix = mat4.create(); 
            // Drag mouse to rotateX & rotateY
            mat4.rotateX(modelViewMatrix,modelViewMatrix,rotateX);   
            mat4.rotateY(modelViewMatrix,modelViewMatrix,rotateY);  
            mat4.rotateZ(modelViewMatrix,modelViewMatrix,rotateZ); 

             // DRAW TREE 3
            colorsBuffer = initBuffers(gl,positionsBox,brownColors); // TRUNK
            mat4.translate(modelViewMatrix,modelViewMatrix,[-5.5,1,-2]);
            mat4.scale(modelViewMatrix,modelViewMatrix,[0.3,1,0.3]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            colorsBuffer = initBuffers(gl,positionsBox,leafColors); // LEAF
            mat4.translate(modelViewMatrix,modelViewMatrix,[0,1.5,0]);
            mat4.scale(modelViewMatrix,modelViewMatrix,[2.5,1,3]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            mat4.translate(modelViewMatrix,modelViewMatrix,[-0.3,1,-0.2]);
            mat4.scale(modelViewMatrix,modelViewMatrix,[0.5,0.5,0.5]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            // DRAW BUSH 1
            colorsBuffer = initBuffers(gl,positionsBox,leafColors); // LEAF
            mat4.translate(modelViewMatrix,modelViewMatrix,[0,-5,16.7]);
            mat4.scale(modelViewMatrix,modelViewMatrix,[1,1,1]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            // DRAW BUSH 2
            mat4.translate(modelViewMatrix,modelViewMatrix,[-1.5,-0.5,0.6]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            // Reset modelViewMatrix to draw another object
            modelViewMatrix = mat4.create(); 
            // Drag mouse to rotateX & rotateY
            mat4.rotateX(modelViewMatrix,modelViewMatrix,rotateX);   
            mat4.rotateY(modelViewMatrix,modelViewMatrix,rotateY);  
            mat4.rotateZ(modelViewMatrix,modelViewMatrix,rotateZ); 

             // DRAW TRUNK
            colorsBuffer = initBuffers(gl,positionsBox,brownColors);
            mat4.translate(modelViewMatrix,modelViewMatrix,[3.5,3.5,6]);
            mat4.scale(modelViewMatrix,modelViewMatrix,[0.3,0.7,0.3]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);
            // ###################################################### //

            // Reset modelViewMatrix to draw another object
            modelViewMatrix = mat4.create(); 
            // Drag mouse to rotateX & rotateY
            mat4.rotateX(modelViewMatrix,modelViewMatrix,rotateX);   
            mat4.rotateY(modelViewMatrix,modelViewMatrix,rotateY);  
            mat4.rotateZ(modelViewMatrix,modelViewMatrix,rotateZ); 

            // DRAW STONE
            // ###################################################### //
            colorsBuffer = initBuffers(gl,positionsBox,darkGreyColors);
            mat4.translate(modelViewMatrix,modelViewMatrix,[3,1.5,5.5]);
            mat4.scale(modelViewMatrix,modelViewMatrix,[1.3,1.5,1.2]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            mat4.translate(modelViewMatrix,modelViewMatrix,[1,-0.5,0.5]);
            mat4.rotateY(modelViewMatrix,modelViewMatrix,30 * 0.0174533);  
            mat4.scale(modelViewMatrix,modelViewMatrix,[-0.7,0.5,-0.7]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            mat4.translate(modelViewMatrix,modelViewMatrix,[2.5,0.3,1.5]);
            mat4.rotateY(modelViewMatrix,modelViewMatrix,-10 * 0.0174533);  
            mat4.scale(modelViewMatrix,modelViewMatrix,[1,1.3,1]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            modelViewMatrix = mat4.create(); 
            // Drag mouse to rotateX & rotateY
            mat4.rotateX(modelViewMatrix,modelViewMatrix,rotateX);   
            mat4.rotateY(modelViewMatrix,modelViewMatrix,rotateY);  
            mat4.rotateZ(modelViewMatrix,modelViewMatrix,rotateZ); 

            mat4.translate(modelViewMatrix,modelViewMatrix,[5,0.3,-5]);
            mat4.rotateY(modelViewMatrix,modelViewMatrix,-10 * 0.0174533);  
            mat4.scale(modelViewMatrix,modelViewMatrix,[1.5,0.3,1]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            modelViewMatrix = mat4.create(); 
            // Drag mouse to rotateX & rotateY
            mat4.rotateX(modelViewMatrix,modelViewMatrix,rotateX);   
            mat4.rotateY(modelViewMatrix,modelViewMatrix,rotateY);  
            mat4.rotateZ(modelViewMatrix,modelViewMatrix,rotateZ); 

            mat4.translate(modelViewMatrix,modelViewMatrix,[-6,0.4,5.5]);
            mat4.rotateY(modelViewMatrix,modelViewMatrix,10 * 0.0174533);  
            mat4.scale(modelViewMatrix,modelViewMatrix,[1.5,0.4,0.9]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);
            // ###################################################### //

            // Reset modelViewMatrix to draw another object
            modelViewMatrix = mat4.create(); 
            // Drag mouse to rotateX & rotateY
            mat4.rotateX(modelViewMatrix,modelViewMatrix,rotateX);   
            mat4.rotateY(modelViewMatrix,modelViewMatrix,rotateY);  
            mat4.rotateZ(modelViewMatrix,modelViewMatrix,rotateZ); 


            // ###################################################### //
            // DRAW SUBMARINE (CHIN)
            // ###################################################### //

            // DRAW SUBMARINE BASE
            colorsBuffer = initBuffers(gl,positionsBox,SubColor);
            mat4.rotateY(modelViewMatrix,modelViewMatrix,-SubMove);    // Rotate Sub towards 0,0 pivot 

            // Do this first before rotating towards the pivot
            mat4.translate(modelViewMatrix,modelViewMatrix,[7,8,0]);        
            let rotorMatrix = mat4.clone(modelViewMatrix); // clone for later "DRAW SUB ROTOR" // Avoid distortion from other scalings
            let frontMatrix = mat4.clone(modelViewMatrix);   
            let BackMatrix = mat4.clone(modelViewMatrix);         
            let WingMatrix = mat4.clone(modelViewMatrix);         
            let Wing1Matrix = mat4.clone(modelViewMatrix);    
            let TailMatrix = mat4.clone(modelViewMatrix);         
            let windowMatrix = mat4.clone(modelViewMatrix);         
    
            mat4.scale(modelViewMatrix,modelViewMatrix,[1.2,1,1.7]);              
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            mat4.translate(modelViewMatrix,modelViewMatrix,[0,0.7,0]);
            mat4.scale(modelViewMatrix,modelViewMatrix,[0.6,1,0.6]);    
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            mat4.translate(modelViewMatrix,modelViewMatrix,[0,0.4,0]);
            mat4.scale(modelViewMatrix,modelViewMatrix,[0.6,0.7,0.6]);    
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            mat4.translate(modelViewMatrix,modelViewMatrix,[0,1.2,0]);
            let TubeMatrix = mat4.clone(modelViewMatrix); // clone for DRAW TUBE         
            mat4.scale(modelViewMatrix,modelViewMatrix,[0.5,1,0.3]);    
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);
            
            // FRONT SUB

            mat4.translate(frontMatrix,frontMatrix,[0,0,1.7]);
            let front1Matrix = mat4.clone(frontMatrix)         
            mat4.scale(frontMatrix,frontMatrix,[1.1,0.94,0.1]);    
            drawScene(gl, programInfo, colorsBuffer, frontMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            mat4.translate(front1Matrix,front1Matrix,[0,0.5,0]);
            mat4.rotateX(front1Matrix,front1Matrix,40 * 0.0174533);
            mat4.scale(front1Matrix,front1Matrix,[1,0.3,0.3]);    
            drawScene(gl, programInfo, colorsBuffer, front1Matrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            mat4.translate(front1Matrix,front1Matrix,[0,-2.4,2.1]);
            mat4.rotateX(front1Matrix,front1Matrix,1 * 0.0174533);
            mat4.scale(front1Matrix,front1Matrix,[1,1,1]);    
            drawScene(gl, programInfo, colorsBuffer, front1Matrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            mat4.translate(front1Matrix,front1Matrix,[0,1.5,-0.85]);
            mat4.rotateX(front1Matrix,front1Matrix,47.5 * 0.0174533);
            mat4.scale(front1Matrix,front1Matrix,[1,1,1.6]);    
            drawScene(gl, programInfo, colorsBuffer, front1Matrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);
            

            // BACK SUB

            colorsBuffer = initBuffers(gl,positionsBox,SubColor);
            mat4.translate(BackMatrix,BackMatrix,[0,0,-1.7]);
            let Back1Matrix = mat4.clone(BackMatrix)         
            mat4.scale(BackMatrix,BackMatrix,[1.1,0.94,0.1]);    
            drawScene(gl, programInfo, colorsBuffer, BackMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            mat4.translate(Back1Matrix,Back1Matrix,[0,0.5,0]);
            mat4.rotateX(Back1Matrix,Back1Matrix,40 * 0.0174533);
            mat4.scale(Back1Matrix,Back1Matrix,[1,0.3,0.3]);    
            drawScene(gl, programInfo, colorsBuffer, Back1Matrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            mat4.translate(Back1Matrix,Back1Matrix,[0,-2.4,2.1]);
            mat4.rotateX(Back1Matrix,Back1Matrix,1 * 0.0174533);
            mat4.scale(Back1Matrix,Back1Matrix,[1,1,1]);    
            drawScene(gl, programInfo, colorsBuffer, Back1Matrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            mat4.translate(Back1Matrix,Back1Matrix,[0,0.8,-1.2]);
            mat4.rotateX(Back1Matrix,Back1Matrix,47.5 * 0.0174533);
            mat4.scale(Back1Matrix,Back1Matrix,[1,1,1.6]);    
            drawScene(gl, programInfo, colorsBuffer, Back1Matrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);


            // DRAW TUBE 

            colorsBuffer = initBuffers(gl,positionsBox,SubColor);
            mat4.translate(TubeMatrix,TubeMatrix,[0,1.1,0.25]);
            mat4.rotateX(TubeMatrix,TubeMatrix,50 * 0.0174533); 
            mat4.scale(TubeMatrix,TubeMatrix,[0.5,0.5,0.3]);  
            //mat4.rotateZ(TubeMatrix,TubeMatrix,TubeMove);   
            drawScene(gl, programInfo, colorsBuffer, TubeMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            mat4.translate(modelViewMatrix,modelViewMatrix,[0,1.35,2.7]);
            mat4.rotateY(modelViewMatrix,modelViewMatrix,TubeMove); 
            mat4.scale(modelViewMatrix,modelViewMatrix,[1.0,0.3,1.3]);    
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            mat4.translate(modelViewMatrix,modelViewMatrix,[0,0,1]);
            //mat4.rotateY(modelViewMatrix,modelViewMatrix,TubeMove); 
            mat4.scale(modelViewMatrix,modelViewMatrix,[1.5,1.4,0.3]);    
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            // TUBE (GLASS)
            
            colorsBuffer = initBuffers(gl,positionsBox,MirrorColor);
            mat4.translate(modelViewMatrix,modelViewMatrix,[0,0,1.2]);
            //mat4.rotateY(modelViewMatrix,modelViewMatrix,TubeMove); 
            mat4.scale(modelViewMatrix,modelViewMatrix,[0.9,0.8,0.3]);    
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            mat4.translate(modelViewMatrix,modelViewMatrix,[0,0,1.2]);
            //mat4.rotateY(modelViewMatrix,modelViewMatrix,TubeMove); 
            mat4.scale(modelViewMatrix,modelViewMatrix,[0.8,0.7,0.3]);    
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            // WING (BACK SUB) WingMatrix,Wing1Matrix

             colorsBuffer = initBuffers(gl,positionsBox,SubColor);
            mat4.translate(WingMatrix,WingMatrix,[0,0.02,-2]);
            mat4.rotateX(WingMatrix,WingMatrix,170 * 0.0174533);
            mat4.rotateX(WingMatrix,WingMatrix,150 * 0.0174533); 
            mat4.scale(WingMatrix,WingMatrix,[0.13,1,0.3]); 
            mat4.rotateX(WingMatrix,WingMatrix,25 * 0.0174533); 
            drawScene(gl, programInfo, colorsBuffer, WingMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            mat4.translate(Wing1Matrix,Wing1Matrix,[0,-0.3,-1.9]);
            mat4.rotateX(Wing1Matrix,Wing1Matrix,100 * 0.0174533);
            mat4.rotateX(Wing1Matrix,Wing1Matrix,170 * 0.0174533);
            mat4.rotateX(Wing1Matrix,Wing1Matrix,150 * 0.0174533); 
            mat4.scale(Wing1Matrix,Wing1Matrix,[0.13,1,0.3]); 
            mat4.rotateX(Wing1Matrix,Wing1Matrix,25 * 0.0174533); 
            drawScene(gl, programInfo, colorsBuffer, Wing1Matrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            // TAIL (BACK SUB) TailMatrix

            mat4.translate(TailMatrix,TailMatrix,[0,-0.05,-2.8]);
            mat4.scale(TailMatrix,TailMatrix,[0.13,0.13,1]);    
            drawScene(gl, programInfo, colorsBuffer, TailMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            mat4.translate(TailMatrix,TailMatrix,[0,-0.05,-1]);
            mat4.scale(TailMatrix,TailMatrix,[1.3,1.3,0.2]);    
            drawScene(gl, programInfo, colorsBuffer, TailMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);


            // Turbine 
            colorsBuffer = initBuffers(gl,positionsBox,rotorColor);
            mat4.translate(rotorMatrix,rotorMatrix,[0,-0.05,-3.8]); 
            mat4.rotateZ(rotorMatrix,rotorMatrix,rotorMove); 
            mat4.scale(rotorMatrix,rotorMatrix,[0.15,0.8,0.05]);   
            drawScene(gl, programInfo, colorsBuffer, rotorMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            // WINDOW windowMatrix
            colorsBuffer = initBuffers(gl,positionsBox,FrameColor);
            mat4.translate(windowMatrix,windowMatrix,[1.2,0,0.8]);
            let window1Matrix = mat4.clone(windowMatrix);
            let window2Matrix = mat4.clone(windowMatrix);      
            mat4.scale(windowMatrix,windowMatrix,[0.08,0.4,0.4]);    
            drawScene(gl, programInfo, colorsBuffer, windowMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            colorsBuffer = initBuffers(gl,positionsBox,MirrorColor);
            mat4.translate(windowMatrix,windowMatrix,[0.5,0,0]);
            mat4.scale(windowMatrix,windowMatrix,[1,-0.8,-0.8]);    
            drawScene(gl, programInfo, colorsBuffer, windowMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            colorsBuffer = initBuffers(gl,positionsBox,FrameColor);
            mat4.translate(window1Matrix,window1Matrix,[0,0,-1.6]);         
            mat4.scale(window1Matrix,window1Matrix,[0.08,0.4,0.4]);    
            drawScene(gl, programInfo, colorsBuffer, window1Matrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            colorsBuffer = initBuffers(gl,positionsBox,MirrorColor);
            mat4.translate(window1Matrix,window1Matrix,[0.5,0,0]);
            mat4.scale(window1Matrix,window1Matrix,[1,-0.8,-0.8]);    
            drawScene(gl, programInfo, colorsBuffer, window1Matrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            colorsBuffer = initBuffers(gl,positionsBox,FrameColor);
            mat4.translate(window2Matrix,window2Matrix,[-2.4,0,0]); 
            let window3Matrix = mat4.clone(window2Matrix);          
            mat4.scale(window2Matrix,window2Matrix,[0.08,0.4,0.4]);    
            drawScene(gl, programInfo, colorsBuffer, window2Matrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            colorsBuffer = initBuffers(gl,positionsBox,MirrorColor);
            mat4.translate(window2Matrix,window2Matrix,[-0.5,0,0]);
            mat4.scale(window2Matrix,window2Matrix,[1,-0.8,-0.8]);    
            drawScene(gl, programInfo, colorsBuffer, window2Matrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);        
            
            colorsBuffer = initBuffers(gl,positionsBox,FrameColor);
            mat4.translate(window3Matrix,window3Matrix,[0,0,-1.6]); 
            mat4.scale(window3Matrix,window3Matrix,[0.08,0.4,0.4]);    
            drawScene(gl, programInfo, colorsBuffer, window3Matrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            colorsBuffer = initBuffers(gl,positionsBox,MirrorColor);
            mat4.translate(window3Matrix,window3Matrix,[-0.5,0,0]);
            mat4.scale(window3Matrix,window3Matrix,[1,-0.8,-0.8]);    
            drawScene(gl, programInfo, colorsBuffer, window3Matrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);   


            // ###################################################### //

            // Reset modelViewMatrix to draw another object
            modelViewMatrix = mat4.create(); 
            // Drag mouse to rotateX & rotateY
            mat4.rotateX(modelViewMatrix,modelViewMatrix,rotateX);   
            mat4.rotateY(modelViewMatrix,modelViewMatrix,rotateY);  
            mat4.rotateZ(modelViewMatrix,modelViewMatrix,rotateZ); 

            // DRAW BOAT
            // ###################################################### //
            colorsBuffer = initBuffers(gl,positionsBox,boatColor);
            mat4.translate(modelViewMatrix,modelViewMatrix,[boatMoveX,0.3,boatMoveZ]);
            mat4.rotateY(modelViewMatrix,modelViewMatrix,boatRotateY * 0.0174533);  
            let boatMatrix = mat4.clone(modelViewMatrix);
            mat4.scale(modelViewMatrix,modelViewMatrix,[0.8,0.3,1]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            // DRAW FRONT
            mat4.translate(boatMatrix,boatMatrix,[0,0,-1]);
            mat4.rotateY(boatMatrix,boatMatrix,45 * 0.0174533);  
            mat4.scale(boatMatrix,boatMatrix,[0.4,0.2,0.4]);
            drawScene(gl, programInfo, colorsBuffer, boatMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            // DRAW BACK
            mat4.translate(boatMatrix,boatMatrix,[-3.5,0,3.5]);
            drawScene(gl, programInfo, colorsBuffer, boatMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            // DRAW POLL
            colorsBuffer = initBuffers(gl,positionsBox,darkGreyColors);
            mat4.translate(modelViewMatrix,modelViewMatrix,[0,5,0]);
            mat4.scale(modelViewMatrix,modelViewMatrix,[0.1,5,0.1]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            // DRAW FLAG
            colorsBuffer = initBuffers(gl,positionsBox,flagColor);
            mat4.rotateY(modelViewMatrix,modelViewMatrix,flagMove); // Rotate towards original origin
            mat4.translate(modelViewMatrix,modelViewMatrix,[0,0.5,5]);
            mat4.scale(modelViewMatrix,modelViewMatrix,[0.1,0.5,5]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

        }
        
        // Array for variance of greyColors
        var greyColors = [   
            [0.7,  0.7,  0.7, 1.0],    
            [0.7,  0.7,  0.7, 1.0],    
            [0.7,  0.7,  0.7, 1.0],    
            [0.7,  0.7,  0.7, 1.0],    
            [0.7,  0.7,  0.7, 1.0],       
            [0.7,  0.7,  0.7, 1.0],      
            [0.7,  0.7,  0.7, 1.0],    
        ];

        var darkGreyColors = [   
            [0.569, 0.569, 0.569, 1.0],  
            [0.569, 0.569, 0.569, 1.0],  
            [0.569, 0.569, 0.569, 1.0],  
            [0.569, 0.569, 0.569, 1.0],  
            [0.569, 0.569, 0.569, 1.0],  
            [0.569, 0.569, 0.569, 1.0],  
        ];

        var greenColors = [ 
            [0, 0.990, 0.990, 1.0],    
            [0, 0.990, 0.990, 1.0],   
            [0, 0.880, 0.880, 1.0],   
            [0, 0.880, 0.880, 1.0],   
            [0, 0.770, 0.770, 1.0],   
            [0, 0.770, 0.770, 1.0],   
        ];

        var pinkColors = [ 
            [0.990, 0, 0.5, 1.0],    
            [0.990, 0, 0.5, 1.0],    
            [0.990, 0, 0.5, 1.0],    
            [0.990, 0, 0.5, 1.0],    
            [0.990, 0, 0.5, 1.0],    
            [0.990, 0, 0.5, 1.0],    
        ];

        var lakeColors = [
            [0.702, 0.929, 1, 1.0],
            [0.702, 0.929, 1, 1.0],
            [0.459, 0.871, 1, 1.0],
            [0.702, 0.929, 1, 1.0],
            [0.702, 0.929, 1, 1.0],
            [0.702, 0.929, 1, 1.0],
        ];

        var brownColors = [
            [0.62, 0.4, 0, 1.0],
            [0.62, 0.4, 0, 1.0],
            [0.62, 0.4, 0, 1.0],
            [0.62, 0.4, 0, 1.0],
            [0.62, 0.4, 0, 1.0],
            [0.62, 0.4, 0, 1.0],
        ];

        var leafColors = [
            [0.051, 1, 0, 1.0],
            [0.051, 1, 0, 1.0],
            [0.051, 1, 0, 1.0],
            [0.051, 1, 0, 1.0],
            [0.051, 1, 0, 1.0],
            [0.051, 1, 0, 1.0],
        ];

        var orangeColors = [
            [1, 0.812, 0, 1.0],
            [1, 0.812, 0, 1.0],
            [1, 0.812, 0, 1.0],
            [1, 0.812, 0, 1.0],
            [1, 0.812, 0, 1.0],
            [1, 0.812, 0, 1.0],
        ];

        var blueColors = [
            [0, 0, 1, 1.0],
            [0, 0, 1, 1.0],
            [0, 0, 1, 1.0],
            [0, 0, 1, 1.0],
            [0, 0, 1, 1.0],
            [0, 0, 1, 1.0],
        ];

        var redColors = [
            [1, 0, 0, 1.0],
            [1, 0, 0, 1.0],
            [1, 0, 0, 1.0],
            [1, 0, 0, 1.0],
            [1, 0, 0, 1.0],
            [1, 0, 0, 1.0],
        ];

        var bluegreyColors = [
            [0.592, 0.655, 0.82, 1.0],
            [0.592, 0.655, 0.82, 1.0],
            [0.592, 0.655, 0.82, 1.0],
            [0.592, 0.655, 0.82, 1.0],
            [0.592, 0.655, 0.82, 1.0],
            [0.592, 0.655, 0.82, 1.0],
        ];

        var lightblueColors = [
            [0.941, 0.957, 1, 1.0],
            [0.941, 0.957, 1, 1.0],
            [0.941, 0.957, 1, 1.0],
            [0.941, 0.957, 1, 1.0],
            [0.941, 0.957, 1, 1.0],
            [0.941, 0.957, 1, 1.0],
        ];

        var darkblueColors = [
            [0.129, 0.196, 0.369, 1.0],
            [0.129, 0.196, 0.369, 1.0],
            [0.129, 0.196, 0.369, 1.0],
            [0.129, 0.196, 0.369, 1.0],
            [0.129, 0.196, 0.369, 1.0],
            [0.129, 0.196, 0.369, 1.0],
        ];

        var rotateX = 0, rotateY = 0, rotateZ = 0;

        // Mouse drag to rotateX & rotateY
        // *******************************
        var prevx, prevy, canvas;
        var dragging = false;

        function doMouseDown(evt) {
            if (dragging)
                return;
            dragging = true;
            document.addEventListener("mousemove", doMouseDrag, false);
            document.addEventListener("mouseup", doMouseUp, false);
            var box = canvas.getBoundingClientRect();
            prevx = window.pageXOffset + evt.clientX - box.left;
            prevy = window.pageYOffset + evt.clientY - box.top;
        }

        function doMouseDrag(evt) {
            if (!dragging)
                return;
            var box = canvas.getBoundingClientRect();
            var x = window.pageXOffset + evt.clientX - box.left;
            var y = window.pageYOffset + evt.clientY - box.top;
            let diffy = (prevx - x) * 0.01;
            let diffx = (prevy - y) * 0.01;
            prevx = x;
            prevy = y;
            rotateX = rotateX - diffx;
            rotateY = rotateY - diffy;
            main();
        }
        
        function doMouseUp(evt) {
            if (dragging) {
                document.removeEventListener("mousemove", doMouseDrag, false);
                document.removeEventListener("mouseup", doMouseUp, false);
                dragging = false;
            }
        }
        
        function resetRotation() {
            rotateX = 0, rotateY = 0, rotateZ = 0;
            main();
        }
        // *******************************
        
        var cubeRotation1 = 0.0, cubeRotation2 = 0.0, cubeRotation3 = 0.0;
        var fieldOfViewC1 = 45, zNear = 0.1, zFar = 50, zPosition = 0, zPositionObj = -10;
        window.onload = main;

        // ########################################### //
        // initBuffers 
        //
        // Initialize the buffers we'll need. For this demo, we just
        // have one object -- a simple three-dimensional cube.
        //
        function initBuffers(gl,positions,faceColors) {

            // Create a buffer for the square's positions.
            const positionBuffer = gl.createBuffer();

            // Select the positionBuffer as the one to apply buffer
            // operations to from here out.
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

            // Now pass the list of positions into WebGL to build the
            // shape. We do this by creating a Float32Array from the
            // JavaScript array, then use it to fill the current buffer.
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

            // ** LIGHTING **
            // Set up the normals for the vertices, so that we can compute lighting.
            const normalBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);

            // ** LIGHTING **
            const vertexNormals = [
                // Front
                0.0,  0.0,  1.0,
                0.0,  0.0,  1.0,
                0.0,  0.0,  1.0,
                0.0,  0.0,  1.0,

                // Back
                0.0,  0.0, -1.0,
                0.0,  0.0, -1.0,
                0.0,  0.0, -1.0,
                0.0,  0.0, -1.0,

                // Top
                0.0,  1.0,  0.0,
                0.0,  1.0,  0.0,
                0.0,  1.0,  0.0,
                0.0,  1.0,  0.0,

                // Bottom
                0.0, -1.0,  0.0,
                0.0, -1.0,  0.0,
                0.0, -1.0,  0.0,
                0.0, -1.0,  0.0,

                // Right
                1.0,  0.0,  0.0,
                1.0,  0.0,  0.0,
                1.0,  0.0,  0.0,
                1.0,  0.0,  0.0,

                // Left
                -1.0,  0.0,  0.0,
                -1.0,  0.0,  0.0,
                -1.0,  0.0,  0.0,
                -1.0,  0.0,  0.0
            ];

            // ** LIGHTING **
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexNormals), gl.STATIC_DRAW);

            // Color buffer                
            var colors = [];

            for (var j = 0; j < faceColors.length; ++j) {
                const c = faceColors[j];
                colors = colors.concat(c, c, c, c);
            }

            const colorBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);

            // Build the element array buffer; this specifies the indices
            // into the vertex arrays for each face's vertices.
            const indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);

            // This array defines each face as two triangles, using the
            // indices into the vertex array to specify each triangle's
            // position.
            const indices = [
                0,  1,  2,      0,  2,  3,    // front
                4,  5,  6,      4,  6,  7,    // back
                8,  9,  10,     8,  10, 11,   // top
                12, 13, 14,     12, 14, 15,   // bottom
                16, 17, 18,     16, 18, 19,   // right
                20, 21, 22,     20, 22, 23,   // left
            ];

            // Now send the element array to GL

            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

            return {
                position: positionBuffer,
                normal: normalBuffer, // ** LIGHTING **
                color: colorBuffer,
                indices: indexBuffer,
            };
        }

        // ########################################### //
        // Draw the scene.
        //
        function drawScene(gl, programInfo, buffers, modelViewMatrix, projectionMatrix) {
            // Tell WebGL how to pull out the positions from the position
            // buffer into the vertexPosition attribute.
            {
                const numComponents = 3; // (x,y,z)
                const type = gl.FLOAT;
                const normalize = false;
                const stride = 0;
                const offset = 0;
                gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
                gl.vertexAttribPointer(
                    programInfo.attribLocations.vertexPosition,
                    numComponents,
                    type,
                    normalize,
                    stride,
                    offset);
                gl.enableVertexAttribArray(
                    programInfo.attribLocations.vertexPosition);
            }

            // Tell WebGL how to pull out the colors from the color buffer
            // into the vertexColor attribute.
            {
                const numComponents = 4; // (r,g,b,a)
                const type = gl.FLOAT;
                const normalize = false;
                const stride = 0;
                const offset = 0;
                gl.bindBuffer(gl.ARRAY_BUFFER, buffers.color);
                gl.vertexAttribPointer(
                    programInfo.attribLocations.vertexColor,
                    numComponents,
                    type,
                    normalize,
                    stride,
                    offset);
                gl.enableVertexAttribArray(
                    programInfo.attribLocations.vertexColor);
            }

            // ** LIGHTING ** Start ---
            var normalMatrix = mat4.create();
            mat4.invert(normalMatrix, modelViewMatrix);
            mat4.transpose(normalMatrix, normalMatrix);

            // Tell WebGL how to pull out the normals from
            // the normal buffer into the vertexNormal attribute.
            {
                const numComponents = 3; // (x, y, z)
                const type = gl.FLOAT;
                const normalize = false;
                const stride = 0;
                const offset = 0;
                gl.bindBuffer(gl.ARRAY_BUFFER, buffers.normal);
                gl.vertexAttribPointer(
                    programInfo.attribLocations.vertexNormal,
                    numComponents,
                    type,
                    normalize,
                    stride,
                    offset);
                gl.enableVertexAttribArray(
                    programInfo.attribLocations.vertexNormal);
            }    
            // ** LIGHTING ** Finish ---

            // Tell WebGL which indices to use to index the vertices
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices);

            // Tell WebGL to use our program when drawing
            gl.useProgram(programInfo.program);

            // Set the shader uniforms
            gl.uniformMatrix4fv(
                programInfo.uniformLocations.projectionMatrix,
                false,
                projectionMatrix);
            gl.uniformMatrix4fv(
                programInfo.uniformLocations.modelViewMatrix,
                false,
                modelViewMatrix);

            // ** LIGHTING **    
            gl.uniformMatrix4fv(
                programInfo.uniformLocations.normalMatrix,
                false,
                normalMatrix);
        }

        // ########################################### //
        // Initialize a shader program, so WebGL knows how to draw our data
        //
        function initShaderProgram(gl, vsSource, fsSource) {
            const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
            const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

            // Create the shader program
            const shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);

            // If creating the shader program failed, alert
            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
                return null;
            }

            return shaderProgram;
        }

        // ########################################### //
        // creates a shader of the given type, uploads the source and
        // compiles it.
        //
        function loadShader(gl, type, source) {
            const shader = gl.createShader(type);

            // Send the source to the shader object
            gl.shaderSource(shader, source);

            // Compile the shader program
            gl.compileShader(shader);

            // See if it compiled successfully
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }

            return shader;
        }

        // ########################################### //
        // CAMERA & PROJECTION functions
        // ########################################### //

        // Reset camera
        function resetCamera() {
            document.getElementById("c1Value").value = 45;
            document.getElementById("c2Value").value = 0;
            document.getElementById("c3Value").value = 0;
            document.getElementById("c4Value").value = 0;
            document.getElementById("c5Value").value = 0;
            document.getElementById("c6Value").value = 0.1;
            document.getElementById("c7Value").value = 500;

            document.getElementById("c1Label").textContent = 45;
            document.getElementById("c2Label").textContent = 0;
            document.getElementById("c3Label").textContent = 0;
            document.getElementById("c4Label").textContent = 0;
            document.getElementById("c5Label").textContent = 0;
            document.getElementById("c6Label").textContent = 0.1;
            document.getElementById("c7Label").textContent = 50;

            rotateX = 0, rotateY = 0, rotateZ = 0;
            fieldOfViewC1 = 45;
            zPosition = 0;
            zNear = 1.0, zFar = 50;
            main();

            
        }
        
        // Field of view
        function changeC1value() {
            let c1Value = parseInt(document.getElementById("c1Value").value, 10);
            document.getElementById("c1Label").innerHTML = c1Value;
            fieldOfViewC1 = c1Value;
            
            main();
            
        }

        // Camera rotate-x
        function changeC2value() {
            let c2Value = document.getElementById("c2Value").value;
            document.getElementById("c2Label").innerHTML = c2Value;
            // convert slider value to "radians" (by multiplying to 0.0174533) and put value into global variable "rotateX"
            rotateX = c2Value * 0.0174533;
            // calling the main() function
            main();  
        }

        // z-Position
        function changeC3value() {
            let c3Value = document.getElementById("c3Value").value;
            document.getElementById("c3Label").innerHTML = c3Value;
            zPosition = c3Value;
            main(); 
        }

        // Camera rotate-y
        function changeC4value() {
            let c4Value = document.getElementById("c4Value").value;
            document.getElementById("c4Label").innerHTML = c4Value;
            // convert slider value to "radians" (by multiplying to 0.0174533) and put value into global variable "rotateX"
            rotateY = c4Value * 0.0174533;
            // calling the main() function
            main();  
        }

        // Camera rotate-z
        function changeC5value() {
            let c5Value = document.getElementById("c5Value").value;
            document.getElementById("c5Label").innerHTML = c5Value;
            // convert slider value to "radians" (by multiplying to 0.0174533) and put value into global variable "rotateX"
            rotateX = c5Value * 0.0174533;
            // calling the main() function
            main();  
        }

        // z-Near
        function changeC6value() {
            let c6Value = document.getElementById("c6Value").value / 10;
            document.getElementById("c6Label").innerHTML = c6Value;
            zNear = c6Value;
            main();
        }

        // z-Far
        function changeC7value() {
            let c7Value = document.getElementById("c7Value").value / 10;
            document.getElementById("c7Label").innerHTML = c7Value;
            zFar = c7Value;
            main();
        }


        // ########################################### //
        // Sub TRANSFORMATION & COLOR functions
        // ########################################### //

        var SubBool = true, SubMove = 0, SubSpeed = 0.2;
        var timer = setInterval(function(){ animateSubMoveLoop() }, 10);

        function stopSubmarine() {
            if (SubBool == true) { SubBool = false; }
            else { SubBool = true; }

            if (SubBool == true) {
                timer = setInterval(function(){ animateSubMoveLoop() }, 10);
                document.getElementById("stopSubmarine").value = "Stop Submarine";
            } else {
                clearInterval(timer);
                document.getElementById("stopSubmarine").value = "Start Submarine";
            }
        }

        function animateSubMoveLoop() {
            if (SubMove > 360) { SubMove = 0; }
            else { SubMove = SubMove + (SubSpeed * 0.0174533);  }
            main();
        }

        function speedSubmarine() {
            SubSpeed = document.getElementById("speedSubmarine").value; 
            document.getElementById("speedsubLabel").innerHTML = SubSpeed;
        }

        // Turbine
        var SubRotorBool = true, rotorMove = 0, rotorSpeed = 50;;
        var timer2 = setInterval(function(){ animateRotorMoveLoop() }, 10);

        function stopChild1() {
            if (SubRotorBool == true) { SubRotorBool = false; }
            else { SubRotorBool = true; }

            if (SubRotorBool == true) {
                timer2 = setInterval(function(){ animateRotorMoveLoop() }, 10);
                document.getElementById("stopChild1").value = "Stop Child 1";
            } else {
                clearInterval(timer2);
                document.getElementById("stopChild1").value = "Start Child 1";
            }
        }

        function animateRotorMoveLoop() {
            if (rotorMove > 360) { rotorMove = 0; }
            else { rotorMove = rotorMove + (rotorSpeed * 0.0174533);  }
            main();
        }

        function speedChild1() {
            rotorSpeed = document.getElementById("speedChild1").value; 
            document.getElementById("sC1Label").innerHTML = rotorSpeed;
        }

        // Tube

        var TubeBool = true, TubeSpinBool = true, TubeMove = -1, TubeSpeed = 0.5;
        var timerTube = setInterval(function(){ animateTubeMoveLoop() }, 10);

        function stopTube() {
            if (TubeBool == true) { TubeBool = false; }
            else { TubeBool = true; }

            if (TubeBool == true) {
                timerTube = setInterval(function(){ animateTubeMoveLoop() }, 10);
                document.getElementById("stopTube").value = "Stop Tube";
            } else {
                clearInterval(timerTube);
                document.getElementById("stopTube").value = "Start Tube";
            }
        }

        function animateTubeMoveLoop() {
            if (TubeMove <= -1) { TubeSpinBool = true; }
            else if (TubeMove >= 1) { TubeSpinBool = false; }

            if (TubeSpinBool == true) { TubeMove += (TubeSpeed * 0.0174533); }
            else { TubeMove -= (TubeSpeed * 0.0174533); }

            main();
        }

        function speedTube() {
            TubeSpeed = document.getElementById("speedTube").value; 
            document.getElementById("TubeLabel").innerHTML = TubeSpeed;
        }



        var SubColor = bluegreyColors, SubColorBool = true;
        function colorSub() {
            if (SubColorBool == true) { SubColorBool = false; } 
            else { SubColorBool = true; }

            alphaParent1(); 
            main();
        }

        var rotorColor = darkGreyColors, rotorColorBool = true;
        function colorSub2() {
            if (rotorColorBool == true) { rotorColorBool = false; } 
            else { rotorColorBool = true; }

            if (rotorColorBool == true) { rotorColor = darkGreyColors; }
            else { rotorColor = greenColors; }

            main();
        }

        var MirrorColor = lightblueColors, MirrorColorBool = true;
        function colorChild1() {
            if (MirrorColorBool == true) { MirrorColorBool = false; } 
            else { MirrorColorBool = true; }

            if (MirrorColorBool == true) { MirrorColor = lightblueColors; }
            else { MirrorColor = greyColors; }

            main();
        }

        var FrameColor = darkblueColors, frameColorBool = true;
        function colorChild1() {
            if (frameColorBool == true) { frameColorBool = false; } 
            else { frameColorBool = true; }

            if (frameColorBool == true) { FrameColor = darkblueColors; }
            else { FrameColor = greyColors; }

            main();
        }


        // var alphaP1Value = 1;
        // function alphaParent1() {
        //     alphaP1Value = document.getElementById("alphaParent1").value / 10; 
        //     document.getElementById("aP1Label").innerHTML = parseFloat(alphaP1Value).toFixed(1);;

        //     if (SubColorBool == true) {
        //         SubColor = [ // pinkColors
        //             [0.990, 0, 0.5, alphaP1Value],    
        //             [0.990, 0, 0.5, alphaP1Value],    
        //             [0.990, 0, 0.5, alphaP1Value],    
        //             [0.990, 0, 0.5, alphaP1Value],    
        //             [0.990, 0, 0.5, alphaP1Value],    
        //             [0.990, 0, 0.5, alphaP1Value],    
        //         ];
        //     } else { 
        //         SubColor = [ // blueColors
        //             [0, 0, 1, alphaP1Value],    
        //             [0, 0, 1, alphaP1Value],    
        //             [0, 0, 1, alphaP1Value],    
        //             [0, 0, 1, alphaP1Value],    
        //             [0, 0, 1, alphaP1Value],    
        //             [0, 0, 1, alphaP1Value],     
        //         ];
        //     }

        //     main();
        // }

        // ########################################### //
        // BOAT TRANSFORMATION & COLOR functions
        // ########################################### //

        var boatBool = true, forwardBool = true, boatRotateY = -60;
        var boatMoveX = -6, boatMoveZ = 2.5, boatSpeedX = 0.005, boatSpeedZ = 0.003, boatSpeedVar = 1;
        var timer3 = setInterval(function(){ animateBoatMoveLoop() }, 10);

        function stopParent2() {
            if (boatBool == true) { boatBool = false; }
            else { boatBool = true; }

            if (boatBool == true) {
                timer3 = setInterval(function(){ animateBoatMoveLoop() }, 10);
                document.getElementById("stopParent2").value = "Stop Parent 2";
            } else {
                clearInterval(timer3);
                document.getElementById("stopParent2").value = "Start Parent 2";
            }
        }

        function animateBoatMoveLoop() {
            if (boatMoveX > 2.07) {
                forwardBool = false;
                boatRotateY = 120;
            } else if (boatMoveX < -5.98) {
                forwardBool = true;
                boatRotateY = -60;
            }

            if (forwardBool == true) {
                boatMoveX += boatSpeedX * boatSpeedVar;
                boatMoveZ -= boatSpeedZ * boatSpeedVar;
            } else {
                boatMoveX -= boatSpeedX * boatSpeedVar;
                boatMoveZ += boatSpeedZ * boatSpeedVar;
            }
            main();
        }

        function speedParent2() {
            boatSpeedVar = document.getElementById("speedParent2").value; 
            document.getElementById("sP2Label").innerHTML = boatSpeedVar;
        }

        var flagBool = true, flagFlipBool = true, flagMove = -1, flagSpeed = 1;
        var timer4 = setInterval(function(){ animateFlagMoveLoop() }, 10);

        function stopChild2() {
            if (flagBool == true) { flagBool = false; }
            else { flagBool = true; }

            if (flagBool == true) {
                timer4 = setInterval(function(){ animateFlagMoveLoop() }, 10);
                document.getElementById("stopChild2").value = "Stop Child 2";
            } else {
                clearInterval(timer4);
                document.getElementById("stopChild2").value = "Start Child 2";
            }
        }

        function animateFlagMoveLoop() {
            if (flagMove <= -1) { flagFlipBool = true; }
            else if (flagMove >= 1) { flagFlipBool = false; }

            if (flagFlipBool == true) { flagMove += (flagSpeed * 0.0174533); }
            else { flagMove -= (flagSpeed * 0.0174533); }

            main();
        }

        function speedChild2() {
            flagSpeed = document.getElementById("speedChild2").value; 
            document.getElementById("sC2Label").innerHTML = flagSpeed;
        }

        var boatColor = orangeColors, boatColorBool = true;
        function colorParent2() {
            if (boatColorBool == true) { boatColorBool = false; } 
            else { boatColorBool = true; }

            alphaParent2(); 
            main();
        }

        var flagColor = blueColors, flagColorBool = true;
        function colorChild2() {
            if (flagColorBool == true) { flagColorBool = false; } 
            else { flagColorBool = true; }

            if (flagColorBool == true) { flagColor = blueColors; }
            else { flagColor = redColors; }

            main();
        }

        var alphaP2Value = 1;
        function alphaParent2() {
            alphaP2Value = document.getElementById("alphaParent2").value / 10; 
            document.getElementById("aP2Label").innerHTML = parseFloat(alphaP2Value).toFixed(1);;

            if (boatColorBool == true) {
                boatColor = [ // orangeColors
                    [1, 0.812, 0, alphaP2Value],
                    [1, 0.812, 0, alphaP2Value],
                    [1, 0.812, 0, alphaP2Value],
                    [1, 0.812, 0, alphaP2Value],
                    [1, 0.812, 0, alphaP2Value],
                    [1, 0.812, 0, alphaP2Value],
                ];
            } else {
                boatColor = [ // pinkColors
                    [0.990, 0, 0.5, alphaP2Value],    
                    [0.990, 0, 0.5, alphaP2Value],   
                    [0.990, 0, 0.5, alphaP2Value],   
                    [0.990, 0, 0.5, alphaP2Value],   
                    [0.990, 0, 0.5, alphaP2Value],   
                    [0.990, 0, 0.5, alphaP2Value],   
                ];
            }

            main();
        }
    </script>
    <style>
        .sceneLabel {
            background-color: #e1e1e1;
            padding: 7px 10px 7px 10px; 
            margin: 7px 5px 0px 5px;
            font-size: 0.9em;
            font-weight: bold;
            -webkit-border-radius: 5px;
            display: inline-block;
            width: auto;
        }
        .objLabel {
            background-color: #e1e1e1;
            padding: 7px 10px 7px 10px; 
            margin: 5px 5px 15px 5px;
            font-size: 0.8em;
            font-weight: bold;
            -webkit-border-radius: 5px;
            display: inline-block;
            width: auto;
        }
        td { font-size: 0.9em; }
    </style>
</head>

<body style="font-family: Arial, Helvetica, sans-serif; text-align: center; font-size: 0.9em;">
    <div style="padding: 10px 0px 5px 0px;">
        <div style="padding-bottom:7px;">Drag mouse inside canvas to rotate ALL OBJECTS on x-axis and y-axis</div>
        <input type="button" id="resetBtn" value="Reset rotation" onclick="resetRotation()">
        <br><div class="sceneLabel">Forest scene: Lake, tree/bush, rock, boat and Submarine</div>
    </div>

    <canvas id="glCanvas" width="640" height="480"></canvas>

    <table width="640" cellpadding="0" cellspacing="5" border="0" align="center">
        <tr><td colspan="2" align="center" style="padding: 5px;">
            <b>CAMERA & PROJECTION</b>&nbsp;&nbsp;
            <input type="button" id="resetCamBtn" value="Reset camera" onclick="resetCamera()">
        </td></tr>
        <tr>
            <td width="30%" align="right">Field of view: <span id="c1Label">45&deg;</span></td>
            <td><input oninput="changeC1value()" id="c1Value" type="range" min="0" max="180" value="45" style="width: 100%"></td>
        </tr>
        <tr>
            <td width="" align="right">Rotate-x (camera): <span id="c2Label">0&deg;</span></td>
            <td><input oninput="changeC2value()" id="c2Value" type="range" min="-180" max="180" value="0" style="width: 100%"></td>
        </tr>
        <tr>
            <td width="" align="right">Rotate-y (camera): <span id="c4Label">0&deg;</span></td>
            <td><input oninput="changeC4value()" id="c4Value" type="range" min="-180" max="180" value="0" style="width: 100%"></td>
        </tr>
        <tr>
            <td width="" align="right">Rotate-z (camera): <span id="c5Label">0&deg;</span></td>
            <td><input oninput="changeC5value()" id="c5Value" type="range" min="-180" max="180" value="0" style="width: 100%"></td>
        </tr>
        <tr>
            <td width="" align="right">z-Position (camera): <span id="c3Label">0</span></td>
            <td><input oninput="changeC3value()" id="c3Value" type="range" min="-50" max="100" value="0" style="width: 100%"></td>
        </tr>

        <tr><td colspan="2" align="center" style="padding: 5px;">
        <div><b>Z-NEAR & Z-FAR</b>&nbsp;&nbsp; </div>
        </td></tr>

        <tr>
            <td width="" align="right">z-Near (camera): <span id="c6Label">0.1</span></td>
            <td><input oninput="changeC6value()" id="c6Value" type="range" min="1" max="500" value="1" style="width: 100%"></td>
        </tr>
        <tr>
            <td width="" align="right">z-Far (camera): <span id="c7Label">50</span></td>
            <td><input oninput="changeC7value()" id="c7Value" type="range" min="1" max="500" value="500" style="width: 100%"></td>
        </tr>
        <tr><td colspan="2"><hr></td></tr>

    </table>
    <div><b>OBJECT TRANSFORMATION & COLOR</b></div>
    <table width="640" cellpadding="0" cellspacing="5" border="0" align="center">  
        <tr>
            <td align="center">
                <div class="objLabel">CD24067 CHIN JIA YIN: Submarine</div><br>
                <!-- parent -->
                <input type="button" id="stopSubmarine" value="Stop Submarine" onclick="stopSubmarine()" style="margin-bottom: 5px;">
                &nbsp;[ <span id="speedsubLabel">1</span> ]
                <br><input oninput="speedSubmarine()" id="speedSubmarine" type="range" min="1" max="10" value="1" style="width: 80%">
                <hr width="80%">
                <!-- child 1 -->
                <input type="button" id="stopChild1" value="Stop Child 1" onclick="stopChild1()" style="margin-bottom: 5px;">
                &nbsp;[ <span id="sC1Label">30</span> ]
                <br><input oninput="speedChild1()" id="speedChild1" type="range" min="1" max="100" value="30" style="width: 80%">
                <hr width="80%">
                <!-- child 2 -->
                <input type="button" id="stopTube" value="Stop Tube" onclick="stopTube()" style="margin-bottom: 5px;">
                &nbsp;[ <span id="TubeLabel">30</span> ]
                <br><input oninput="speedTube()" id="speedTube" type="range" min="1" max="100" value="30" style="width: 80%">
                <hr width="80%">
                <!-- color -->
                RGB[A: <span id="aP1Label">1.0</span>]&nbsp; 
                <input type="button" id="colorSub" value="Sub" onclick="colorSub()" style="margin-bottom: 5px;">
                <input type="button" id="colorSub2" value="Turbine" onclick="colorSub2()" style="margin-bottom: 5px;">
                <br><input oninput="alphaParent1()" id="alphaParent1" type="range" min="0" max="10" value="10" style="width: 80%">
            </td>

            <td align="center">
                <div class="objLabel">CD54321 SALIIMI: Boat</div><br>
                <input type="button" id="stopParent2" value="Stop Parent 2" onclick="stopParent2()" style="margin-bottom: 5px;">
                &nbsp;[ <span id="sP2Label">1</span> ]
                <br><input oninput="speedParent2()" id="speedParent2" type="range" min="1" max="10" value="1" style="width: 80%">
                <hr width="80%">
                <input type="button" id="stopChild2" value="Stop Child 2" onclick="stopChild2()" style="margin-bottom: 5px;">
                &nbsp;[ <span id="sC2Label">1</span> ]
                <br><input oninput="speedChild2()" id="speedChild2" type="range" min="1" max="10" value="1" style="width: 80%">
                <hr width="80%">
                RGB[A: <span id="aP2Label">1.0</span>]&nbsp; 
                <input type="button" id="colorParent2" value="Parent 2" onclick="colorParent2()" style="margin-bottom: 5px;">
                <input type="button" id="colorChild2" value="Child 2" onclick="colorChild2()" style="margin-bottom: 5px;">
                <br><input oninput="alphaParent2()" id="alphaParent2" type="range" min="0" max="10" value="10" style="width: 80%">
            </td>
            <!-- UNCOMMENTS FOR OTHER MEMBERS -->
            <!-- <td align="center">
                <div class="objLabel">CD0000 NAME: Object name</div><br>
                <input type="button" id="stopParent3" value="Stop Parent 3" onclick="stopParent3()" style="margin-bottom: 5px;">
                &nbsp;[ <span id="sP3Label">1</span> ]
                <br><input oninput="speedParent3()" id="speedParent3" type="range" min="1" max="10" value="1" style="width: 80%">
                <hr width="80%">
                <input type="button" id="stopChild3" value="Stop Child 3" onclick="stopChild3()" style="margin-bottom: 5px;">
                &nbsp;[ <span id="sC3Label">1</span> ]
                <br><input oninput="speedChild3()" id="speedChild3" type="range" min="1" max="10" value="1" style="width: 80%">
                <hr width="80%">
                RGB[A: <span id="aP3Label">1.0</span>]&nbsp; 
                <input type="button" id="colorParent3" value="Parent 3" onclick="colorParent3()" style="margin-bottom: 5px;">
                <input type="button" id="colorChild3" value="Child 3" onclick="colorChild3()" style="margin-bottom: 5px;">
                <br><input oninput="alphaParent3()" id="alphaParent3" type="range" min="0" max="10" value="10" style="width: 80%">
            </td> -->
        </tr> 
    </table>
</body>